schema {
  query: Query
  mutation: Mutation
}

directive @locale(
  """The language to use"""
  lang: String!
) on FIELD

"""
Every queries available on the GraphQL API

If you have more queries that you would like added, make a new issue here

https://github.com/tcgdex/cards-database/issues/new/choose
"""
type Query {
  addOn(id: ID!): AddOn
  calendarWidget(id: ID!, startingDate: String!): CalendarWidget!
  calendarWidgets(hostId: ID!, startingDate: String!): [CalendarWidget]!
  categories(keywords: String): [Category!]!
  commissionCodes(code: PricingPlan, currencies: [CurrencyCode!]!): [CommissionCode!]!
  discount(id: ID!): Discount!
  """Discounts created for a given event and discount codes that match a searchQuery"""
  discountCodes(eventId: ID!, searchQuery: String): DiscountConnection
  event(id: ID!): Event!
  eventSet(id: ID!): EventSet!
  getStripeTerminalLocation(listingId: ID, currency: CurrencyCode): StripeTerminalLocation
  getStripeTerminalReader(stripeTerminalReaderId: ID!, currency: CurrencyCode, listingId: ID): StripeTerminalReader
  getStripeTerminalReaders(listingId: ID, currency: CurrencyCode, paginationAttributes: StripePaginationAttributesInputType): StripeTerminalReaderCollection
  host(id: ID!): Host!
  listingAttractions(listingId: ID!): [Attraction!]
  manageBasics(id: ID!): ManageBasics!
  manageChannelPartnerSales(id: ID!): [ManageChannelPartnerSales!]!
  manageCustomize(id: ID!): ManageCustomize!
  manageCustomizeTickets(id: ID!, startingDate: String!): ManageCustomizeTickets!
  manageTickets(id: ID!): ManageTickets!
  manageWhenRegularEntry(id: ID!): ManageWhenRegularEntry!
  manageWhenTimedEntry(id: ID!): ManageWhenTimedEntry!
  order(id: ID!): Order!
  orderItem(id: ID!): OrderItem!
  orderItems(
    """Select order items on a given order"""
    id: ID!
  ): [OrderItem!]!
  partnerOffers(id: ID!, channelPartnerId: ID): [PartnerOffers!]!
  profile(id: ID, slug: String): Profile!
  rateUpgrade(id: ID!): RateUpgrade!
  settlementCurrency(latitude: Float!, longitude: Float!): CurrencyCode
  ticketmasterAttractions(match: String, hostId: ID): TicketmasterAttractionConnection!
  ticketmaster_venues(search: String, filters: JSON = "{}"): TicketmasterVenuesConnection!
  timeSlotSelect(id: ID!): TimeSlotSelect!
  timeslotFilter(id: ID!, startTimeBefore: String, startTimeAfter: String): TimeslotFilter!
  timezone(latitude: Float!, longitude: Float!): String
  transactionCurrency(latitude: Float!, longitude: Float!): CurrencyCode
  transfer(token: String!): Transfer!
  upgradableOrder(id: ID!, orderItemId: ID): UpgradableOrder!
  userExternalEmails: [String!]!
  viewer: Viewer!
  whitelistedCountries: [Country!]!
  wrstbndIntegration: WrstbndIntegration
  wrstbndPasstype(id: ID!): WrstbndPasstype
  """Find the cards"""
  cards(filters: CardsFilters, pagination: Pagination, sort: Sort): [Card]
  """Find the sets"""
  sets(filters: SetFilters, pagination: Pagination, sort: Sort): [Set]
  """Find the series"""
  series(filters: SerieFilters, pagination: Pagination, sort: Sort): [Serie]
  """Find one card (using the id and set is deprecated)"""
  card(
    id: ID
    set: String
    """The new way to filter"""
    filters: CardsFilters
  ): Card
  """Find one set (using the id is deprecated)"""
  set(
    id: ID
    """The new way to filter"""
    filters: SetFilters
  ): Set
  """Find one serie (using the id is deprecated)"""
  serie(
    id: ID
    """The new way to filter"""
    filters: SerieFilters
  ): Serie
}

type Mutation {
  """Accept Transfer"""
  acceptTransfer(input: TransferAcceptInput!): TransferAcceptPayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `transferAccept`")
  """Create AddOn"""
  addOnCreate(input: AddOnCreateInput!): AddOnCreatePayload
  """Delete AddOn"""
  addOnDelete(input: AddOnDeleteInput!): AddOnDeletePayload
  """Update Addon"""
  addOnUpdate(input: AddOnUpdateInput!): AddOnUpdatePayload
  """Message event attendees"""
  attendeesMessage(input: AttendeesMessageInput!): AttendeesMessagePayload
  """Update the time slot for orders"""
  bulkOrderTimeSlotUpdate(input: BulkOrderTimeSlotUpdateInput!): BulkOrderTimeSlotUpdatePayload
  """Toggle the status of channel partner offers"""
  channelPartnerOffersStatusToggle(input: ChannelPartnerOffersStatusToggleInput!): ChannelPartnerOffersStatusTogglePayload
  """Create AddOn"""
  createAddOn(input: AddOnCreateInput!): AddOnCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnCreate`")
  """Create Custom Report"""
  createCustomReport(input: CustomReportCreateInput!): CustomReportCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportCreate`")
  """Create Event"""
  createEvent(input: EventCreateInput!): EventCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventCreate`")
  """Create Tax"""
  createTax(input: TaxCreateInput!): TaxCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `taxCreate`")
  """Create Custom Report"""
  customReportCreate(input: CustomReportCreateInput!): CustomReportCreatePayload
  """Delete Custom Report"""
  customReportDelete(input: CustomReportDeleteInput!): CustomReportDeletePayload
  """Update Custom Report"""
  customReportUpdate(input: CustomReportUpdateInput!): CustomReportUpdatePayload
  """Decline Transfer"""
  declineTransfer(input: TransferDeclineInput!): TransferDeclinePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `transferDecline`")
  """Delete AddOn"""
  deleteAddOn(input: AddOnDeleteInput!): AddOnDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnDelete`")
  """Delete Custom Report"""
  deleteCustomReport(input: CustomReportDeleteInput!): CustomReportDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportDelete`")
  """Delete Event"""
  deleteEvent(input: EventDeleteInput!): EventDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventDelete`")
  """Create Discount belonging to this user"""
  discountCreate(input: DiscountCreateInput!): DiscountCreatePayload
  """Delete Discount"""
  discountDelete(input: DiscountDeleteInput!): DiscountDeletePayload
  """Bulk create account level discount codes"""
  discountsCreate(input: DiscountsCreateInput!): DiscountsCreatePayload
  """Update many Discounts at once"""
  discountsUpdate(input: DiscountsUpdateInput!): DiscountsUpdatePayload
  """Duplicate Event"""
  duplicateEvent(input: EventDuplicateInput!): EventDuplicatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventDuplicate`")
  """Create Event"""
  eventCreate(input: EventCreateInput!): EventCreatePayload
  """Delete Event"""
  eventDelete(input: EventDeleteInput!): EventDeletePayload
  """Duplicate Event"""
  eventDuplicate(input: EventDuplicateInput!): EventDuplicatePayload
  """Publish Event"""
  eventPublish(input: EventPublishInput!): EventPublishPayload
  """Report Event"""
  eventReport(input: EventReportInput!): EventReportPayload
  """Save Event"""
  eventSave(input: EventSaveInput!): EventSavePayload
  """Report Event Set"""
  eventSetReport(input: EventSetReportInput!): EventSetReportPayload
  """Unpublish Event"""
  eventUnpublish(input: EventUnpublishInput!): EventUnpublishPayload
  """Update Event"""
  eventUpdate(input: EventUpdateInput!): EventUpdatePayload
  """Delete Host Field"""
  hostFieldDelete(input: HostFieldDeleteInput!): HostFieldDeletePayload
  """Update host google analytics integration"""
  hostGaIntegrationUpdate(input: HostGaIntegrationUpdateInput!): HostGaIntegrationUpdatePayload
  """Change locale for current Viewer"""
  localeChange(input: LocaleChangeInput!): LocaleChangePayload
  """Approves a pending order"""
  orderApprove(input: OrderApproveInput!): OrderApprovePayload
  """Change the buyer info for an order"""
  orderBuyerInfoChange(input: OrderBuyerInfoChangeInput!): OrderBuyerInfoChangePayload
  """Declines a pending order"""
  orderDecline(input: OrderDeclineInput!): OrderDeclinePayload
  """Change the attendee info for an order item"""
  orderItemAttendeeInfoChange(input: OrderItemAttendeeInfoChangeInput!): OrderItemAttendeeInfoChangePayload
  """Check in an order item"""
  orderItemCheckIn(input: OrderItemCheckInInput!): OrderItemCheckInPayload
  """Check out an order item"""
  orderItemCheckOut(input: OrderItemCheckOutInput!): OrderItemCheckOutPayload
  """Update external metadata field on OrderItem"""
  orderItemExternalMetadataUpdate(input: ExternalMetadataUpdateInput!): ExternalMetadataUpdatePayload
  """Resend email with order item details"""
  orderItemResend(input: OrderItemResendInput!): OrderItemResendPayload
  """Marks an order that was purchased using an invoice as 'Paid'"""
  orderMarkInvoiceAsPaid(input: MarkInvoiceAsPaidInput!): MarkInvoiceAsPaidPayload
  """Refund order items"""
  orderRefund(input: OrderRefundInput!): OrderRefundPayload
  """Resend email with order details"""
  orderResend(input: OrderResendInput!): OrderResendPayload
  """Update the time slot for an order"""
  orderTimeSlotUpdate(input: OrderTimeSlotUpdateInput!): OrderTimeSlotUpdatePayload
  """Upgrade order items"""
  orderUpgrade(input: OrderUpgradeInput!): OrderUpgradePayload
  """Manage PrintedTicketConfiguration"""
  printedTicketConfigurationManage(input: PrintedTicketConfigurationManageInput!): PrintedTicketConfigurationManagePayload
  """Create PrintingLog"""
  printingLogCreate(input: PrintingLogCreateInput!): PrintingLogCreatePayload
  """Publish Event"""
  publishEvent(input: EventPublishInput!): EventPublishPayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventPublish`")
  """Create a ticket"""
  rateCreate(input: RateCreateInput!): RateCreatePayload
  """Update a single rate"""
  rateUpdate(input: RateUpdateInput!): RateUpdatePayload
  """Create a rate upgrade"""
  rateUpgradeCreate(input: RateUpgradeCreateInput!): RateUpgradeCreatePayload
  """Delete a rate upgrade"""
  rateUpgradeDelete(input: RateUpgradeDeleteInput!): RateUpgradeDeletePayload
  """Update a rate upgrade"""
  rateUpgradeUpdate(input: RateUpgradeUpdateInput!): RateUpgradeUpdatePayload
  """Update multiple rates"""
  ratesUpdate(input: RatesUpdateInput!): RatesUpdatePayload
  """Resends email confirmation email"""
  resendEmailConfirmation(input: ResendEmailConfirmationInput!): ResendEmailConfirmationPayload
  """Save Event"""
  saveEvent(input: EventSaveInput!): EventSavePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventSave`")
  """Makes API call to Seats.io to publish a seating map"""
  seatsPublishDraft(input: SeatsPublishDraftInput!): SeatsPublishDraftPayload
  """Synchronize rates with seats chart for reserved seated events"""
  seatsSyncRates(input: SeatsSyncRatesInput!): SeatsSyncRatesPayload
  """Register a stripe terminal location"""
  stripeTerminalLocationCreate(input: StripeTerminalLocationCreateInput!): StripeTerminalLocationCreatePayload
  """Cancel stripe terminal reader"""
  stripeTerminalReaderCancel(input: StripeTerminalReaderCancelInput!): StripeTerminalReaderCancelPayload
  """Register a stripe terminal reader"""
  stripeTerminalReaderCreate(input: StripeTerminalReaderCreateInput!): StripeTerminalReaderCreatePayload
  """Delete a stripe terminal reader"""
  stripeTerminalReaderDelete(input: StripeTerminalReaderDeleteInput!): StripeTerminalReaderDeletePayload
  """Update a stripe terminal reader"""
  stripeTerminalReaderUpdate(input: StripeTerminalReaderUpdateInput!): StripeTerminalReaderUpdatePayload
  """Create Tax"""
  taxCreate(input: TaxCreateInput!): TaxCreatePayload
  """Delete all the tickets from the selected third party providers"""
  thirdPartyTicketDeleteByProvider(input: ThirdPartyTicketDeleteByProviderInput!): ThirdPartyTicketDeleteByProviderPayload
  """Allows the mass importing of ThirdPartyTicket from Third Party Ticket Providers"""
  thirdPartyTicketImport(input: ImportThirdPartyTicketInput!): ImportThirdPartyTicketPayload
  """Add or update a timeslot ticket customization"""
  timeSlotRateCustomization(input: TimeslotRateCustomizationInput!): TimeslotRateCustomizationPayload
  """Updates a TimeSlot"""
  timeSlotUpdate(input: TimeSlotUpdateInput!): TimeSlotUpdatePayload
  """Accept Transfer"""
  transferAccept(input: TransferAcceptInput!): TransferAcceptPayload
  """Decline Transfer"""
  transferDecline(input: TransferDeclineInput!): TransferDeclinePayload
  """Update Addon"""
  updateAddOn(input: AddOnUpdateInput!): AddOnUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnUpdate`")
  """Update Custom Report"""
  updateCustomReport(input: CustomReportUpdateInput!): CustomReportUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportUpdate`")
  """Update a single rate"""
  updateRate(input: RateUpdateInput!): RateUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `rateUpdate`")
  """Update multiple rates"""
  updateRates(input: RatesUpdateInput!): RatesUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `ratesUpdate`")
  """Create a new waitlist subscription"""
  waitlistSubscriberCreate(input: WaitlistSubscriberCreateInput!): WaitlistSubscriberCreatePayload
}

"""A user who is selling tickets to Events on Universe"""
type Host implements User {
  """Account balance of the host"""
  accountBalance: AccountBalanceConnection
  """Add on order items"""
  addOnOrderItems(
    """Search query for add on order items"""
    search: String
    """Only returns add on order items after this date."""
    from: Date
    """Only returns add on order items for this state"""
    checkInState: CheckInState
    states: [OrderItemState!]
    page: Int = 1
    perPage: Int = 10
  ): OrderItemConnection
  """Account level rates that belong to this host."""
  addOns(
    """state of add-ons to return"""
    state: String
    listingId: ID
    currency: CurrencyCode
  ): AddOnConnection!
  admin: Boolean!
  """Analytics data for this host (have to be the host or have membership to the host's organization)"""
  analytics: Analytics!
  """A list of all attendees for all Events and all TimeSlots for which this host has sold tickets on Universe. Includes tickets from all states, including invalid."""
  attendees: AttendeeConnection!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The user has configured their account as a business - does not have a last name"""
  business: Boolean!
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """Chargebacks against the host"""
  chargebacks(currency: String!): ChargebackConnection
  """The Commission Codes (pricing details) the host is set to for any currency/countries they have sold tickets for - does not include any event or rate specific custom overrides"""
  commissionCodes: [CommissionCode!]!
  """the settlement currencies of the host (have to be the host or have membership to the host's organization)"""
  currencies: [CurrencyCode!]!
  """An account level custom report belonging to this host"""
  customReport(id: ID!): CustomReport!
  """All account level custom reports created by this host"""
  customReports(
    """Search query for custom reports"""
    search: String
  ): CustomReportConnection!
  """A list of dates with future / ongoing events"""
  datesCalendar: [Date!]!
  """A user-defined description"""
  description: String
  """Account level discounts that belong to this host. Sorted by state (ascending), then code name"""
  discounts(
    search: String
    """return only discount codes updated since this time"""
    updatedSince: Time
  ): DiscountConnection!
  """Returns calculated all in pricing for a single rate"""
  displayPrice(settlementCurrency: String!, country: String!, price: Float!, rateId: ID): Float
  """The settlement currencies used on events by the host"""
  eventCurrencies: [CurrencyCode!]!
  """All Events by this host (have to be the host or have membership to the host's organization)"""
  events(slugs: [String!], currency: CurrencyCode, states: [EventState!], search: String): EventConnection!
  """All Events (events that have sales) by this host (sorted by live Events (ascending order), then expired / archived events  (have to be the host or have membership to the host's organization)."""
  eventsWithTickets(
    currency: CurrencyCode
    """Only return Events within the specified time frame"""
    from: Date
    """Only return Events within the specified time frame"""
    to: Date
    """Include events that have sales (not free tickets)"""
    paid: Boolean
    """Include events that have free ticket sales"""
    free: Boolean
  ): EventConnection!
  """All non-hidden Events within the given range that were hosted by this user."""
  eventsWithTicketsInRange(
    currency: CurrencyCode
    """Only return Events within the specified time frame"""
    from: Date
    """Only return Events within the specified time frame"""
    to: Date
  ): EventConnection!
  """Feature flags for a host organization"""
  features: Features!
  """The first name of the type implementing a User interface"""
  firstName: String
  """Whether the host can choose to pass on Universe service fees to the buyer."""
  forceHostToPayCommission: Boolean
  """Google Analytics Ecommerce"""
  googleAnalyticsEcommerce: Boolean
  """Google Analytics Id"""
  googleAnalyticsId: String
  hasLiveEvents: Boolean
  """Events hosted by this host with past Time Slots sorted by their most recently ended timeslot endAt, unique by Event (have to be the host or have membership to the host's organization)"""
  hosted(state: EventState): EventConnection!
  """Events hosted by this host with future Time Slots (have to be the host or have membership to the host's organization)"""
  hosting(states: [EventState!], currency: CurrencyCode, transactionalCurrency: CurrencyCode, slugs: [String!], addOnId: ID): EventConnection!
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A single field concatenating firstName and lastName"""
  name: String
  """The next upcoming event in a host's event list."""
  nextFutureEvent: Event
  """Orders created for inventory owned by this host"""
  orders: OrderConnection
  organization: Organization!
  """Whether the organization has rebate functionality enabled."""
  rebates: Boolean
  """All events for this host ordered by the most recently updated"""
  recentlyUpdatedEvents(states: [EventState!]): EventConnection!
  report(
    """type of report"""
    name: String = "AttendeesReport"
    """columns to return"""
    columns: [String] = []
    """array of {key: value} or 'string' where clauses"""
    clauses: [JSON] = []
  ): Report!
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """The seats designer key from Seats.io. Used to embed the seats.io floor plan designer."""
  seatsDesignerKey: String
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  """Events hosted by this host with Time Slots sorted by their starting timeslot startAt"""
  sortedEvents(states: [EventState!]): EventConnection!
  """Linked stripe connect accounts"""
  stripeConnectAccounts: [StripeConnectAccount]!
  superAdmin: Boolean!
  """Taxes created by this host"""
  taxes: TaxConnection
  """A list of ongoing / future TimeSlots, sorted by startAt, unique by startDate and Event."""
  timeSlotsCalendar(
    """Supply an ISO8601-formatted date string to filter time slots by date"""
    date: Date
  ): TimeSlotConnection!
  """The transactional currencies used on events by the host"""
  transactionalCurrencies: [CurrencyCode!]!
  """Count of unread messages for a host"""
  unreadMessagesCount: Int
  """Withdrawal made by the host"""
  withdrawals(currency: String!): WithdrawalConnection
}

"""The most common 'person'-level interface in Universe"""
interface User {
  admin: Boolean!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """A user-defined description"""
  description: String
  """The first name of the type implementing a User interface"""
  firstName: String
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A single field concatenating firstName and lastName"""
  name: String
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
}

"""Possible roles a user can have"""
enum UserRole {
  """The user has the default account type"""
  USER
  """The user has been marked as a spammer"""
  SPAMMER
  """The user has an admin account"""
  ADMIN
  """The user has a super admin account"""
  SUPER_ADMIN
  """The user has a developer account"""
  DEVELOPER
  """The user has a sales account"""
  SALES
  """The user has a sales admin account"""
  SALES_ADMIN
  """The user has a (tm) finance account"""
  FINANCE
  """The user has a finance admin account"""
  FINANCE_ADMIN
  """The user has an Agent (call centre) account"""
  AGENT
}

"""Supported locales"""
enum Locale {
  """English"""
  EN
  """Deutsch"""
  DE
  """Español"""
  ES
  """Français"""
  FR
  """Nederlands"""
  NL
  """Dansk"""
  DA
  """Svenska"""
  SV
  """Norsk Bokmål"""
  NB
  """Nederlands (België)"""
  NL_BE
  """Ελληνικά"""
  EL
  """Suomen kieli"""
  FI
}

"""the organization owned by a particular user"""
type Organization {
  commissionCode: String!
  """In UTC"""
  createdAt: Time!
  """Feature flags for an organization"""
  features: Features!
  id: ID!
  members: [Member!]
  name: String
  """In UTC"""
  updatedAt: Time!
}

"""Organization members of user making the current GraphQL operation"""
type Member implements User {
  admin: Boolean!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """The user has configured email"""
  confirmed: Boolean
  """A user-defined description"""
  description: String
  """A (potentially unconfirmed) email address belong to the Viewer"""
  email: String
  """The first name of the type implementing a User interface"""
  firstName: String
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A single field concatenating firstName and lastName"""
  name: String
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
}

"""Show features flags status"""
type Features {
  """Emails for non team members"""
  allowEmailReportsForNonTeamMembers: Boolean!
  """Artist section on EDP"""
  artistSectionOnEDP: Boolean!
  """Ticketmaster attraction tagging"""
  attractionTagging: Boolean!
  """Credit card BIN restrictions"""
  cardRestrictions: Boolean!
  """Allow confirmation emails customization"""
  customizableConfirmationEmails: Boolean!
  """Hiding confirmation emails customization feature"""
  customizableConfirmationEmailsBeta: Boolean!
  """Additional payment types"""
  enableAdditionalPaymentTypes: Boolean!
  """Event summary settlement report"""
  eventSummarySettlementReport: Boolean!
  """Allow facility fees to tagged TM venues"""
  facilityFee: Boolean!
  """Highlander reporting engine (beta)"""
  highlander: Boolean!
  """Host Added Fee Presets"""
  hostAddedFeePresets: Boolean!
  """Multi-User Management"""
  mum: Boolean!
  """Pay by Invoice"""
  payByInvoice: Boolean!
  """Payment plans"""
  paymentPlans: Boolean!
  """Payout settlement report"""
  payoutSettlementReport: Boolean!
  """PayPal available as payment method"""
  paypal: Boolean!
  """Seats.io integration [DEPRECATED]"""
  seats: Boolean!
  """Third Party Barcodes self-import"""
  thirdPartyBarcodes: Boolean!
  """Tiered Tickets"""
  tieredTickets: Boolean!
  """TM audit report"""
  tmAuditReport: Boolean!
  """Venue Tagging"""
  venueTagging: Boolean!
  """Waitlist Reports"""
  waitlistFanOptIn: Boolean!
  """Wrstbnd integration"""
  wrstbndIntegration: Boolean!
}

"""Time string with timezone in ISO 8601 format. eg. 2017-09-15T17:50:00-04:00"""
scalar Time

"""Date string in ISO 8601 format: YYYY-mm-dd"""
scalar Date

type CommissionCode {
  brokerFee: Float!
  code: String!
  country: CountryCode
  currency: CurrencyCode!
  flat: Float
  id: ID!
  max: Float
  percent: Float
}

"""ISO 3166-1 alpha-2 country codes"""
enum CountryCode {
  """Andorra"""
  AD
  """United Arab Emirates"""
  AE
  """Afghanistan"""
  AF
  """Antigua and Barbuda"""
  AG
  """Anguilla"""
  AI
  """Albania"""
  AL
  """Armenia"""
  AM
  """Netherlands Antilles"""
  AN
  """Angola"""
  AO
  """Antarctica"""
  AQ
  """Argentina"""
  AR
  """American Samoa"""
  AS
  """Austria"""
  AT
  """Australia"""
  AU
  """Aruba"""
  AW
  """Åland Islands"""
  AX
  """Azerbaijan"""
  AZ
  """Bosnia and Herzegovina"""
  BA
  """Barbados"""
  BB
  """Bangladesh"""
  BD
  """Belgium"""
  BE
  """Burkina Faso"""
  BF
  """Bulgaria"""
  BG
  """Bahrain"""
  BH
  """Burundi"""
  BI
  """Benin"""
  BJ
  """Saint Barthélemy"""
  BL
  """Bermuda"""
  BM
  """Brunei Darussalam"""
  BN
  """Bolivia"""
  BO
  """Bonaire, Saint Eustatius and Saba"""
  BQ
  """Brazil"""
  BR
  """Bahamas"""
  BS
  """Bhutan"""
  BT
  """Bouvet Island"""
  BV
  """Botswana"""
  BW
  """Belarus"""
  BY
  """Belize"""
  BZ
  """Canada"""
  CA
  """Cocos (Keeling) Islands"""
  CC
  """Congo"""
  CD
  """Central African Republic"""
  CF
  """Congo"""
  CG
  """Switzerland"""
  CH
  """Côte d'Ivoire"""
  CI
  """Cook Islands"""
  CK
  """Chile"""
  CL
  """Cameroon"""
  CM
  """China"""
  CN
  """Colombia"""
  CO
  """Costa Rica"""
  CR
  """Serbia and Montenegro"""
  CS
  """Cuba"""
  CU
  """Cape Verde"""
  CV
  """Curaçao"""
  CW
  """Christmas Island"""
  CX
  """Cyprus"""
  CY
  """Czech Republic"""
  CZ
  """Germany"""
  DE
  """Djibouti"""
  DJ
  """Denmark"""
  DK
  """Dominica"""
  DM
  """Dominican Republic"""
  DO
  """Algeria"""
  DZ
  """Ecuador"""
  EC
  """Estonia"""
  EE
  """Egypt"""
  EG
  """Western Sahara"""
  EH
  """Eritrea"""
  ER
  """Spain"""
  ES
  """Ethiopia"""
  ET
  """Finland"""
  FI
  """Fiji"""
  FJ
  """Falkland Islands (Malvinas)"""
  FK
  """Micronesia"""
  FM
  """Faroe Islands"""
  FO
  """France"""
  FR
  """Gabon"""
  GA
  """United Kingdom"""
  GB
  """Grenada"""
  GD
  """Georgia"""
  GE
  """French Guiana"""
  GF
  """Guernsey"""
  GG
  """Ghana"""
  GH
  """Gibraltar"""
  GI
  """Greenland"""
  GL
  """Gambia"""
  GM
  """Guinea"""
  GN
  """Guadeloupe"""
  GP
  """Equatorial Guinea"""
  GQ
  """Greece"""
  GR
  """South Georgia and the South Sandwich Islands"""
  GS
  """Guatemala"""
  GT
  """Guam"""
  GU
  """Guinea-Bissau"""
  GW
  """Guyana"""
  GY
  """Hong Kong"""
  HK
  """Heard Island and McDonald Islands"""
  HM
  """Honduras"""
  HN
  """Croatia"""
  HR
  """Haiti"""
  HT
  """Hungary"""
  HU
  """Indonesia"""
  ID
  """Ireland"""
  IE
  """Israel"""
  IL
  """Isle of Man"""
  IM
  """India"""
  IN
  """British Indian Ocean Territory"""
  IO
  """Iraq"""
  IQ
  """Iran"""
  IR
  """Iceland"""
  IS
  """Italy"""
  IT
  """Jersey"""
  JE
  """Jamaica"""
  JM
  """Jordan"""
  JO
  """Japan"""
  JP
  """Kenya"""
  KE
  """Kyrgyzstan"""
  KG
  """Cambodia"""
  KH
  """Kiribati"""
  KI
  """Comoros"""
  KM
  """Saint Kitts and Nevis"""
  KN
  """North Korea"""
  KP
  """South Korea"""
  KR
  """Kuwait"""
  KW
  """Cayman Islands"""
  KY
  """Kazakhstan"""
  KZ
  """Lao"""
  LA
  """Lebanon"""
  LB
  """Saint Lucia"""
  LC
  """Liechtenstein"""
  LI
  """Sri Lanka"""
  LK
  """Liberia"""
  LR
  """Lesotho"""
  LS
  """Lithuania"""
  LT
  """Luxembourg"""
  LU
  """Latvia"""
  LV
  """Libya"""
  LY
  """Morocco"""
  MA
  """Monaco"""
  MC
  """Moldova"""
  MD
  """Montenegro"""
  ME
  """Saint Martin"""
  MF
  """Madagascar"""
  MG
  """Marshall Islands"""
  MH
  """Macedonia"""
  MK
  """Mali"""
  ML
  """Myanmar"""
  MM
  """Mongolia"""
  MN
  """Macao"""
  MO
  """Northern Mariana Islands"""
  MP
  """Martinique"""
  MQ
  """Mauritania"""
  MR
  """Montserrat"""
  MS
  """Malta"""
  MT
  """Mauritius"""
  MU
  """Maldives"""
  MV
  """Malawi"""
  MW
  """Mexico"""
  MX
  """Malaysia"""
  MY
  """Mozambique"""
  MZ
  """Namibia"""
  NA
  """New Caledonia"""
  NC
  """Niger"""
  NE
  """Norfolk Island"""
  NF
  """Nigeria"""
  NG
  """Nicaragua"""
  NI
  """Netherlands"""
  NL
  """Norway"""
  NO
  """Nepal"""
  NP
  """Nauru"""
  NR
  """Niue"""
  NU
  """New Zealand"""
  NZ
  """Oman"""
  OM
  """Panama"""
  PA
  """Peru"""
  PE
  """French Polynesia"""
  PF
  """Papua New Guinea"""
  PG
  """Philippines"""
  PH
  """Pakistan"""
  PK
  """Poland"""
  PL
  """Saint Pierre and Miquelon"""
  PM
  """Pitcairn"""
  PN
  """Puerto Rico"""
  PR
  """Palestine"""
  PS
  """Portugal"""
  PT
  """Palau"""
  PW
  """Paraguay"""
  PY
  """Qatar"""
  QA
  """Réunion"""
  RE
  """Romania"""
  RO
  """Serbia"""
  RS
  """Russia"""
  RU
  """Rwanda"""
  RW
  """Saudi Arabia"""
  SA
  """Solomon Islands"""
  SB
  """Seychelles"""
  SC
  """Sudan"""
  SD
  """Sweden"""
  SE
  """Singapore"""
  SG
  """Saint Helena, Ascension and Tristan da Cunha"""
  SH
  """Slovenia"""
  SI
  """Svalbard and Jan Mayen"""
  SJ
  """Slovakia"""
  SK
  """Sierra Leone"""
  SL
  """San Marino"""
  SM
  """Senegal"""
  SN
  """Somalia"""
  SO
  """Suriname"""
  SR
  """South Sudan"""
  SS
  """Sao Tome and Principe"""
  ST
  """El Salvador"""
  SV
  """Sint Maarten"""
  SX
  """Syrian Arab Republic"""
  SY
  """Swaziland"""
  SZ
  """Turks and Caicos Islands"""
  TC
  """Chad"""
  TD
  """French Southern Territories"""
  TF
  """Togo"""
  TG
  """Thailand"""
  TH
  """Tajikistan"""
  TJ
  """Tokelau"""
  TK
  """Timor-Leste"""
  TL
  """Turkmenistan"""
  TM
  """Tunisia"""
  TN
  """Tonga"""
  TO
  """Turkey"""
  TR
  """Trinidad and Tobago"""
  TT
  """Tuvalu"""
  TV
  """Taiwan"""
  TW
  """Tanzania"""
  TZ
  """Ukraine"""
  UA
  """Uganda"""
  UG
  """United States Minor Outlying Islands"""
  UM
  """United States"""
  US
  """Uruguay"""
  UY
  """Uzbekistan"""
  UZ
  """Vatican City"""
  VA
  """Saint Vincent and the Grenadines"""
  VC
  """Venezuela"""
  VE
  """British Virgin Islands"""
  VG
  """US Virgin Islands"""
  VI
  """Viet Nam"""
  VN
  """Vanuatu"""
  VU
  """Wallis and Futuna"""
  WF
  """Samoa"""
  WS
  """Kosovo"""
  XK
  """Yemen"""
  YE
  """Mayotte"""
  YT
  """South Africa"""
  ZA
  """Zambia"""
  ZM
  """Zimbabwe"""
  ZW
}

"""ISO 4217 currency codes"""
enum CurrencyCode {
  """د.إ AED"""
  AED
  """؋ AFN"""
  AFN
  """L ALL"""
  ALL
  """դր. AMD"""
  AMD
  """ƒ ANG"""
  ANG
  """Kz AOA"""
  AOA
  """$ ARS"""
  ARS
  """$ AUD"""
  AUD
  """ƒ AWG"""
  AWG
  """AZN"""
  AZN
  """КМ BAM"""
  BAM
  """$ BBD"""
  BBD
  """৳ BDT"""
  BDT
  """лв BGN"""
  BGN
  """ب.د BHD"""
  BHD
  """Fr BIF"""
  BIF
  """$ BMD"""
  BMD
  """$ BND"""
  BND
  """Bs. BOB"""
  BOB
  """R$ BRL"""
  BRL
  """$ BSD"""
  BSD
  """B⃦ BTC"""
  BTC
  """Nu. BTN"""
  BTN
  """P BWP"""
  BWP
  """Br BYN"""
  BYN
  """$ BZD"""
  BZD
  """$ CAD"""
  CAD
  """Fr CDF"""
  CDF
  """Fr CHF"""
  CHF
  """UF CLF"""
  CLF
  """$ CLP"""
  CLP
  """¥ CNY"""
  CNY
  """$ COP"""
  COP
  """₡ CRC"""
  CRC
  """$ CUC"""
  CUC
  """$ CUP"""
  CUP
  """$ CVE"""
  CVE
  """Kč CZK"""
  CZK
  """Fdj DJF"""
  DJF
  """kr DKK"""
  DKK
  """$ DOP"""
  DOP
  """د.ج DZD"""
  DZD
  """ج.م EGP"""
  EGP
  """Nfk ERN"""
  ERN
  """Br ETB"""
  ETB
  """€ EUR"""
  EUR
  """$ FJD"""
  FJD
  """£ FKP"""
  FKP
  """£ GBP"""
  GBP
  """ლ GEL"""
  GEL
  """GGP"""
  GGP
  """₵ GHS"""
  GHS
  """£ GIP"""
  GIP
  """D GMD"""
  GMD
  """Fr GNF"""
  GNF
  """Q GTQ"""
  GTQ
  """$ GYD"""
  GYD
  """$ HKD"""
  HKD
  """L HNL"""
  HNL
  """kn HRK"""
  HRK
  """G HTG"""
  HTG
  """Ft HUF"""
  HUF
  """Rp IDR"""
  IDR
  """₪ ILS"""
  ILS
  """IMP"""
  IMP
  """<U+20B9> INR"""
  INR
  """ع.د IQD"""
  IQD
  """﷼ IRR"""
  IRR
  """kr ISK"""
  ISK
  """£ JEP"""
  JEP
  """$ JMD"""
  JMD
  """د.ا JOD"""
  JOD
  """¥ JPY"""
  JPY
  """KSh KES"""
  KES
  """som KGS"""
  KGS
  """៛ KHR"""
  KHR
  """Fr KMF"""
  KMF
  """₩ KPW"""
  KPW
  """₩ KRW"""
  KRW
  """د.ك KWD"""
  KWD
  """$ KYD"""
  KYD
  """〒 KZT"""
  KZT
  """₭ LAK"""
  LAK
  """ل.ل LBP"""
  LBP
  """₨ LKR"""
  LKR
  """$ LRD"""
  LRD
  """L LSL"""
  LSL
  """ل.د LYD"""
  LYD
  """د.م. MAD"""
  MAD
  """L MDL"""
  MDL
  """Ar MGA"""
  MGA
  """ден MKD"""
  MKD
  """K MMK"""
  MMK
  """₮ MNT"""
  MNT
  """P MOP"""
  MOP
  """UM MRO"""
  MRO
  """₨ MUR"""
  MUR
  """MVR MVR"""
  MVR
  """MK MWK"""
  MWK
  """$ MXN"""
  MXN
  """RM MYR"""
  MYR
  """MTn MZN"""
  MZN
  """$ NAD"""
  NAD
  """₦ NGN"""
  NGN
  """C$ NIO"""
  NIO
  """kr NOK"""
  NOK
  """₨ NPR"""
  NPR
  """$ NZD"""
  NZD
  """ر.ع. OMR"""
  OMR
  """B/. PAB"""
  PAB
  """S/. PEN"""
  PEN
  """K PGK"""
  PGK
  """₱ PHP"""
  PHP
  """₨ PKR"""
  PKR
  """zł PLN"""
  PLN
  """₲ PYG"""
  PYG
  """ر.ق QAR"""
  QAR
  """Lei RON"""
  RON
  """РСД RSD"""
  RSD
  """р. RUB"""
  RUB
  """FRw RWF"""
  RWF
  """ر.س SAR"""
  SAR
  """$ SBD"""
  SBD
  """₨ SCR"""
  SCR
  """£ SDG"""
  SDG
  """kr SEK"""
  SEK
  """$ SGD"""
  SGD
  """£ SHP"""
  SHP
  """Le SLL"""
  SLL
  """Sh SOS"""
  SOS
  """$ SRD"""
  SRD
  """Db STD"""
  STD
  """₡ SVC"""
  SVC
  """£S SYP"""
  SYP
  """L SZL"""
  SZL
  """฿ THB"""
  THB
  """ЅМ TJS"""
  TJS
  """m TMT"""
  TMT
  """د.ت TND"""
  TND
  """T$ TOP"""
  TOP
  """TL TRY"""
  TRY
  """$ TTD"""
  TTD
  """$ TWD"""
  TWD
  """Sh TZS"""
  TZS
  """₴ UAH"""
  UAH
  """USh UGX"""
  UGX
  """$ USD"""
  USD
  """$ UYU"""
  UYU
  """ UZS"""
  UZS
  """BsF VEF"""
  VEF
  """₫ VND"""
  VND
  """Vt VUV"""
  VUV
  """T WST"""
  WST
  """Fr XAF"""
  XAF
  """ozt XAG"""
  XAG
  """ozt XAU"""
  XAU
  """$ XCD"""
  XCD
  """SDR XDR"""
  XDR
  """Fr XOF"""
  XOF
  """XPD"""
  XPD
  """Fr XPF"""
  XPF
  """XPT"""
  XPT
  """﷼ YER"""
  YER
  """R ZAR"""
  ZAR
  """ZK ZMK"""
  ZMK
  """ZK ZMW"""
  ZMW
  """$ ZWL"""
  ZWL
}

type TimeSlotConnection {
  nodes(limit: Int, offset: Int = 0): [TimeSlot!]!
  pagination: JSON
  totalCount: Int!
}

"""A range of time with a start and an end, for which tickets are sellable. A single Event may have one or many TimeSlots. For example, a three day Event could be configured either with one TimeSlot (say Friday to Monday), or with three Timeslots (one for each of Friday, Saturday, and Sunday). """
type TimeSlot {
  """A list of all attendees for the Event, includes tickets from all states, including invalid."""
  attendees: AttendeeConnection!
  """Capacity of the timeslot"""
  capacity: Int
  """In UTC"""
  createdAt: Time!
  """In Event's time zone"""
  endAt: TimeWithoutTz!
  """In Event's time zone"""
  endDate: Date!
  """UNIX Timestamp"""
  endStamp: Int!
  event: Event!
  id: ID!
  """Orders created for this Event"""
  orders: OrderConnection!
  """Rate capacities for the Event"""
  rateCapacities: RateCapacityConnection!
  rates(states: [RateState!]): [Rate!]
  """Rate event capacities for the Event"""
  ratesAvailablity(states: [RateState!]): [JSON]
  report(
    """type of report"""
    name: String = "AttendeesReport"
    """columns to return"""
    columns: [String] = []
    """array of {key: value} or 'string' where clauses"""
    clauses: [JSON] = []
  ): Report!
  """Future or ongoing TimeSlots for the same Event within the same day"""
  sameDayTimeSlots: TimeSlotConnection!
  """In Event's time zone"""
  startAt: TimeWithoutTz!
  """In Event's time zone"""
  startDate: Date!
  """UNIX Timestamp"""
  startStamp: Int!
  state: TimeSlotState!
  timeSlotReport: TimeSlotReport!
  """An IANA Time Zone string"""
  tz: String!
  """In UTC"""
  updatedAt: Time!
}

"""The state an Event can be in"""
enum TimeSlotState {
  """No valid tickets have been sold for the event"""
  UNBOOKED
  """The event has valid tickets associated with it"""
  NORMAL
  """The event is sold out, no capacity remains"""
  FULL
  """The event has been removed"""
  HIDDEN
}

"""Time string without timezone. E.g. 2017-09-15T17:50:00"""
scalar TimeWithoutTz

"""The root-level inventory object. Events are entitites for which tickets can be sold. Events support multiple dates/times for which tickets can be sold separately as TimeSlots. In previous APIs, Universe has referred to this as a Listing."""
type Event implements BaseEvent {
  """Access Keys created for this Event"""
  accessKeys: AccessKeyConnection
  """Event has sold tickets for timeslots in the future"""
  active: Boolean!
  """Add-on sales by day"""
  addOnSalesByDay(from: Date!, to: Date!): [DailySales!]!
  addOns: [AddOn]!
  """Optional additional images for the event (promotional photos, venue photos)"""
  additionalImages: [Image!]!
  """Street-level address"""
  address: String!
  """All future or ongoing TimeSlots for which tickets can be purchased"""
  allAvailableTimeSlots: [TimeSlot]!
  """All Additional Images"""
  allImages: [Image!]!
  allRatesFree: Boolean
  """All dates/times for which tickets can be purchased sorted chronologically. Each Event can define one or many TimeSlots"""
  allTimeSlots: [TimeSlot]!
  """Whether to enable waitlist for the Event"""
  allowWaitlist: Boolean!
  """A list of all attendees for the Event, includes tickets from all states, including invalid."""
  attendees(after: Time, before: Time, externalMetadata: String, states: [OrderItemState], timeSlotIds: [ID!], match: String, sortOrder: String = "asc"): AttendeeConnection!
  """A list of countries in which tickets to this event may be purchased"""
  availableCountries: [CountryCode]!
  """Future or ongoing TimeSlots for which tickets can be purchased"""
  availableTimeSlots: TimeSlotConnection!
  """Total event capacity of the event"""
  capacity: Int
  """The category assigned for this Event"""
  category: Category
  """Seats chart information regarding if the listing's chart is in a DRAFT state and if its events have yet been linked"""
  chartStatus: JSON
  """Name of the city"""
  cityName: String
  """Optional field that the host sets for additional contact information"""
  contactDetails: String
  continentCode: String
  """The country code"""
  countryCode: String
  """Cover photo for the event (min 100x100px, max 2MB). Auto-generated if no initial entry."""
  coverPhoto: Image!
  """In UTC"""
  createdAt: Time!
  """The settlement currency specified by Host"""
  currency: CurrencyCode!
  """Whether this event is enabled for DCOM"""
  dcomEnabled: Boolean!
  """A detailed description of the event"""
  description(format: ContentFormat = TEXT): String!
  """Discounts created for this Event"""
  discounts(include_global_discount_codes: Boolean = false): DiscountConnection
  """Event photo for the event (min 1110x444px, max 5MB). Auto-generated if no initial entry."""
  eventPhoto: Image!
  """Facebook pixel codes"""
  facebookPixelCodes: [String!]!
  facebookPixels: [FacebookPixel!]!
  """The number of future time slots"""
  futureTimeSlotCount: Int!
  """Total sales amount for future timeslots only (returns null if no future timeslots)"""
  futureTimeslotsSalesAmount: Money
  """Total tickets sold for upcoming timeslots only (returns null if no future timeslots)"""
  futureTimeslotsTicketsSold: Int
  """The ticket purchase button text"""
  getTicketsText: String!
  """the 'send_to' field for a GoogleAds conversion to be tracked. Has the form: AW-123456789/AbC-D_efG-h12_34-567"""
  googleAdsSendTos: GoogleAdsSendTos
  googleAdsTrackers: [GoogleAdsTracker!]!
  """Google analytics 4 id. Format: G-XXXXXXX"""
  googleAnalytics4Id: String
  """Google analytics e-commerce enabled bool"""
  googleAnalyticsEcommerce: Boolean
  """Google analytics id. Format: UA-1234561-2"""
  googleAnalyticsId: String
  """Whether the Event is sells Passes"""
  hasPasses: Boolean!
  """Whether the Event uses reserved seating"""
  hasSeats: Boolean!
  """A user-configurable setting determining whether the TimeSlot of the Event should be disclosed to the Buyer"""
  hiddenDate: Boolean!
  hideAttractionsFromTicketmaster: Boolean
  """Whether to show or hide this Event from our Calendar / Listings widgets."""
  hideFromWidgets: Boolean
  host: Host!
  """Host fields for checkout questions"""
  hostFields: [HostField!]!
  id: ID!
  """A URL to the event image. Custom height and width can be supplied"""
  imageUrl(
    """Height of the image"""
    height: Int = 160
    """Width of the image"""
    width: Int = 160
  ): String
  """Other Images"""
  images: ImageConnection!
  """Date that the event was last updated"""
  lastUpdated: Date!
  latitude: Float!
  lnAllInPricing: Boolean
  longitude: Float!
  """Mailchimp API key"""
  mailchimpApiKey: String
  """Mailchimp list id"""
  mailchimpListId: String
  """Maximum Price of an event. If provided, indicates a range"""
  maxPrice: Float
  """Maximum number of items which are sellable for Event.The value depends on Rates' maxQuantity."""
  maxQuantity: Int
  """Minimum Price of an event"""
  minPrice: Float
  needsApproval: Boolean
  """The next active time slot of future time slots"""
  nextFutureTimeSlot: TimeSlot
  """Whether per order fee is applicable to this event or not"""
  orderFeeApplicable: Boolean!
  """Orders created for this Event"""
  orders(states: [OrderState], state: OrderState, paymentMethod: PaymentMethod, timeSlotIds: [ID!], match: String, updatedSince: Time, sortOrder: String = "asc"): OrderConnection
  """Whether payment plans are disabled for this listing"""
  paymentPlanDisabled: Boolean!
  """Provide Payment Provider Info"""
  paymentProvider: String!
  """Provide Payment Provider Account Number"""
  paymentProviderAccountNumber: String
  """Provide Payment Provider Key"""
  paymentProviderKey: String!
  paymentSettings: PaymentSettings!
  """Does the event accept PayPal payments"""
  paypal: Boolean!
  printedTicketConfiguration: PrintedTicketConfiguration
  """The privacy setting for the Event"""
  privacy: EventPrivacy!
  """Content that will be provided to buyer's only"""
  privateNote(format: ContentFormat = TEXT): String
  """When the draft event is scheduled to be published (not set if not scheduled)"""
  publishLaterAt: Time
  """Listing questions on checkout"""
  questions: [Question]!
  """Customized values for Ticket Type - Timeslot pairs"""
  rateCustomizations(event_ids: [String!] = []): [RateCustomization!]!
  rateStateExists: RateStateExists!
  rateUpgrades: [RateUpgrade!]
  """Product types (Tickets or Passes) that can be sold for this Event"""
  rates(states: [RateState!], clientGroups: [RateClientGroup!]): RateConnection!
  """Whether the Event uses rebates"""
  rebates: Boolean!
  """Referral codes for this Event"""
  referralCodes(sortOrder: String = "asc"): [ReferralCode!]!
  """Time (in seconds) setting how long refunds are available for - pairs with refundOffsetType"""
  refundOffset: Int!
  """Refund will be available either within refundOffset units of purchase or until refundOffset units before the event"""
  refundOffsetType: String!
  """Describes a policy on ticket refunds"""
  refundPolicy: RefundPolicy
  """Region where the event is being hosted"""
  region: String
  report(
    """type of report"""
    name: String = "AttendeesReport"
    """columns to return"""
    columns: [String] = []
    """array of {key: value} or 'string' where clauses"""
    clauses: [JSON] = []
  ): Report!
  """Total sales amount for this Event"""
  salesAmount: Money
  """Sales by day"""
  salesByDay(from: Date!, to: Date!): [DailySales!]!
  """Whether the Event Saved by the Viewer"""
  saved: Boolean!
  """List of all Savers who saved the Event"""
  savers: SaversConnection
  """The schedules assigned to this Event"""
  schedules: ScheduleConnection
  """Whether the Seats.io chart has been published for its first time"""
  seatingMapPublished: Boolean!
  """The seats chart key from Seats.io"""
  seatsChartKey: String
  """Determines whether or not to show quantity filter"""
  showQuantityFilter: Boolean!
  """Determines whether or not to show ticket type filter"""
  showTicketTypeFilter: Boolean!
  """Determines whether or not to show time of day filter"""
  showTimeOfDayFilter: Boolean!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String!
  """A parameterized version of slug used for URI construction"""
  slugParam: String!
  """Whether the Social Buttons will be active on unlisted events"""
  socialButtons: Boolean!
  """Tickets are sold out for this Event"""
  soldOut: Boolean!
  """The Event state"""
  state: EventState!
  """The tags added to this Event"""
  tags: [Tag]!
  """A list of all external attendees for the Event, includes tickets from all states, including invalid."""
  thirdPartyTickets(importSource: String, match: String, timeSlotIds: [ID!], page: Int = 1, perPage: Int = 10): ThirdPartyTicketConnection!
  """A list of all external attendees providers name for the Event"""
  thirdPartyTicketsProviders: [String!]!
  """Ticket sales by day"""
  ticketSalesByDay(from: Date!, to: Date!): [DailySales!]!
  """Total tickets sold for this Event"""
  ticketsSold: Int
  timeSlotReport: TimeSlotReport!
  """A date/time for which tickets can be purchased sorted chronologically. Each Event can define one or many TimeSlots"""
  timeSlots(
    ids: [String!] = []
    """Start time of event before end of day"""
    startTimeBefore: Date
    """Start time of event after beginning of day"""
    startTimeAfter: Date
    """End time of event before end of day"""
    endTimeBefore: Date
    """End time of event after beginning of day"""
    endTimeAfter: Date
  ): TimeSlotConnection!
  """Determines whether or not an event admits visitors to an event between a set time"""
  timedEntry: Boolean!
  """Timezone of the event location"""
  timezone: String!
  """A brief description"""
  title: String!
  """Currency that is displayed and charged in"""
  transactionCurrency: CurrencyCode!
  """The total number of tickets which are sellable for upcoming TimeslotsThe value is the lowest of the upcoming Rates maxQuantity and upcoming Timeslots capacities"""
  upcomingTotalCapacity: Int
  """In UTC"""
  updatedAt: Time!
  """When to show an alert that the Event is almost sold out"""
  urgencyIndicatorEnabled: Boolean
  """When to show an alert that the Event is almost sold out"""
  urgencyIndicatorThreshold: Float
  """Event URL"""
  url: String!
  """Event or EventSet creator"""
  user: Profile!
  """Name of the venue"""
  venueName: String
  """Is the event virtual?"""
  virtual: Boolean!
  """Virtual connection info"""
  virtualInfo: String!
  waitlistCount: Int
  waitlistSubscribers: [WaitlistSubscriber!]
  """Is Wrstbnd integration enabled?"""
  wrstbndEnabled: Boolean!
  """Wrstbnd integration data"""
  wrstbndIntegration: WrstbndIntegration!
}

"""The most low level version of an event, representing both events and event sets"""
interface BaseEvent {
  """Street-level address"""
  address: String!
  """All Additional Images"""
  allImages: [Image!]!
  """Cover Photo"""
  coverPhoto: Image!
  """A detailed description of the event"""
  description(format: ContentFormat = TEXT): String!
  """Hidden Date"""
  hiddenDate: Boolean
  id: ID!
  """Other Images"""
  images: ImageConnection!
  latitude: Float!
  longitude: Float!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String!
  """A brief description"""
  title: String!
  """Event or EventSet creator"""
  user: Profile!
  """Name of the venue"""
  venueName: String
}

"""Supported content formats."""
enum ContentFormat {
  TEXT
  HTML
}

"""A Profile for a Universe account - an interface into a User as a Host or Buyer"""
type Profile implements User {
  admin: Boolean!
  """Public-visibility Events in the past associated with Orders purchased by this account"""
  attended: EventConnection
  """Public-visiblity Events in the future associated with Orders purchased by this account"""
  attending: EventConnection
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The Profile is for a user who has configured their account as a business"""
  business: Boolean
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """The cover photo URL in the original size"""
  coverPhotoUrl: String
  """A user-defined description"""
  description: String
  """Facebook account URI"""
  facebook: String
  """The first name of the type implementing a User interface"""
  firstName: String
  """The Profile is for a user hosting events on Universe"""
  host: Boolean
  """Public-visibility Events with no future Time Slots hosted by this account"""
  hosted: EventConnection
  """Public-visibility Events with future Time Slots hosted by this account"""
  hosting: EventConnection
  id: ID
  """Instagram account URI"""
  instagram: String
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A plain-text user-inputed string referring to their self-defined location"""
  location: String
  """Determines if a user is messageable"""
  messageable: Boolean
  """A single field concatenating firstName and lastName"""
  name: String
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
  """Twitter account URI"""
  twitter: String
  """The Profile URI"""
  url: String!
  visibility: ProfileVisibility!
  """A stringified URI, user-inputed"""
  website: String
}

"""Possible visibility states a Profile can be in"""
enum ProfileVisibility {
  """Public (recommended)"""
  PUBLIC
  """Hidden from search engines"""
  HIDDEN
  """Private"""
  PRIVATE
}

type EventConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Event!]!
  pagination: JSON
  totalCount: Int!
}

"""A raw all-or-nothing JSON object"""
scalar JSON

"""Image for events, avatars, and add on options"""
type Image {
  cropHeight: Int
  cropWidth: Int
  cropX: Int
  cropY: Int
  isGif: Boolean
  uploadId: String!
  """Image URL. Custom height and width can be supplied"""
  url(
    """Height of the image"""
    height: Int = 160
    """Width of the image"""
    width: Int = 160
    """Blur images by the strength factor. Default: '500'"""
    blur: Int
    """Adjust image quality. Default: 'NORMAL'"""
    quality: ImageQuality
    """Convert an image to one of the supported output formats"""
    format: ImageFormat
    """Resize or crop the image."""
    cropMode: ImageCropMode = SCALE_CROP
  ): String!
}

"""Adjust image quality. Works with JPEG and WEBP formats."""
enum ImageQuality {
  """≈50% file size compared to 'NORMAL'"""
  LIGHTEST
  """≈80% file size"""
  LIGHTER
  """≈100% file size"""
  NORMAL
  """≈125% file size"""
  BETTER
  """≈170% file size"""
  BEST
}

"""Supported output formats."""
enum ImageFormat {
  JPEG
  PNG
  WEBP
}

"""Set the image crop mode."""
enum ImageCropMode {
  """Resize Image Proportionally"""
  PREVIEW
  """Resize Image"""
  RESIZE
  """Crop Image"""
  CROP
  """Downscale and Crop Image"""
  SCALE_CROP
}

type ImageConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Image!]!
  pagination: JSON
  totalCount: Int!
}

"""The privacy setting for an Event"""
enum EventPrivacy {
  """The default privacy setting - publicly searchable"""
  PUBLIC
  """The Event is private, not publicly searchable"""
  PRIVATE
}

"""The Event state determines whether Orders can be created (assuming available inventory). To be sellable, the Event MUST be in the POSTED state."""
enum EventState {
  """The Event is not complete, default state"""
  DRAFT
  """The Event is complete, but the Host's account has not been confirmed (i.e. email ownership has been confirmed)"""
  PRESUBMITTED
  """The Event is complete, and available to sell tickets for"""
  POSTED
  EXPIRED
  ARCHIVED
  """The Event has been disabled by a moderator"""
  DECLINED
  INACTIVE
}

"""Settings related to means of payment on an Event."""
type PaymentSettings {
  """Payment methods available to pay for an Order."""
  methodsAvailable: [PaymentMethod!]!
  """Payment methods available to pay for an Order."""
  methodsEnabled: [PaymentMethod!]!
  """Sales can be performed where the Credit Card payment method only accepts specific card brands (i.e. an Amex only presale). If empty, there are no restrictions. Note that these brand restrictions will only be applied to the Credit Card payment method. If other payment methods are enabled on the Event, they will not be brand restricted."""
  restrictedCardBrands: [CardBrand!]!
  """Security methods available to pay for an Order."""
  securityMethodsAvailable: [PaymentMethod!]!
  """Security methods enabled to pay for an Order."""
  securityMethodsEnabled: [PaymentMethod!]!
}

enum PaymentMethod {
  ALIPAY
  BANCONTACT
  EPS
  GIROPAY
  GLOBEE
  IDEAL
  KLARNA
  INVOICE
  MASTERPASS
  MULTIBANCO
  SEPA
  SOFORT
  PRZELEWY
  WECHAT
  VISACHECKOUT
  DCOM
  PAYPAL
  OFFLINE
  CARD
  APPLE_PAY
  GOOGLE_PAY
}

"""Credit Card brands supported by our payment systems"""
enum CardBrand {
  AMERICAN_EXPRESS
  DINERS_CLUB
  DISCOVER
  JCB
  MASTERCARD
  UNIONPAY
  VISA
  UNKNOWN
}

"""Rule describing when ticket refunds should be allowed"""
type RefundPolicy {
  offset: RefundOffset!
  type: RefundOffsetType!
}

"""What is the time of your refund policy?"""
enum RefundOffset {
  """Your refund policy will affect 1 day"""
  ONE_DAY
  """Your refund policy will affect 2 days"""
  TWO_DAYS
  """Your refund policy will affect 3 days"""
  THREE_DAYS
  """Your refund policy will affect 7 days"""
  ONE_WEEK
  """Your refund policy will affect 30 days"""
  THIRTY_DAYS
  """Your refund policy will affect 60 days"""
  SIXTY_DAYS
  """Your refund policy will affect 90 days"""
  NINETY_DAYS
  """Tickets can never be refunded"""
  NEVER
}

"""What is the scope of your refund policy?"""
enum RefundOffsetType {
  """Your refund policy will be calculated from the event date"""
  EVENT
  """Your refund policy will be calculated from the ticket purchase date"""
  PURCHASE
}

type AttendeeConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Attendee!]!
  pagination: JSON
  totalCount: Int!
}

"""A ticket-holder"""
type Attendee {
  """Attendee-speicific answers to checkout questions on the OrderItem level (i.e. Ticket)"""
  answers: [Answer]!
  email: String!
  """The Event the attendee is attending"""
  event: Event!
  firstName: String!
  id: ID!
  lastName: String
  """The Order which generated this attendee"""
  order: Order!
  """The individual OrderItem on the Order which is for this attendee"""
  orderItem: OrderItem!
  """Typically, the ticket-type belonging to the attendee."""
  rate: Rate!
  """The state of the Order this attendee's ticket was purchased via - note, importantly, that this can be an invalid state. If you are using this information to validate a guest list, you should filter your results for only those tickets you consider valid."""
  state: OrderItemState!
  """The TimeSlot of the Event the attendee is attending"""
  timeSlot: TimeSlot!
  """The token that the individual will present in order to gain access to the event. Typically in the form of a QRCode."""
  token: String!
}

"""OrderItemState describes the possible states an OrderItem may be in."""
enum OrderItemState {
  """The OrderItem has been created and a charge has been authorized but not yet processed - the default state"""
  UNPAID
  """The OrderItem has been created, but requires approval by the Host to process"""
  UNAPPROVED
  """This state has been deprecated, and will be removed soon"""
  CHECKOUT
  """The OrderItem has been created but a charge has not yet been authorized"""
  PENDING
  """The OrderItem has been successfully processed, and payment methods have been charged"""
  PAID
  """The OrderItem has been processed, and processing failed"""
  FAILED
  """The OrderItem has been processed, but the payment method was declined by the upstream gateway"""
  DECLINED
  """The OrderItem was created and processed, but has since been cancelled and any associated transactions have been reverted"""
  CANCELLED
  """The OrderItem was created and processed, and 48 hours has passed since the Event. The funds associated with this OrderItem are now pending a transfer to the Host"""
  ENDED
  """The OrderItem has been processed, and funds captured by the charge have been transferred to the Event Host"""
  CLOSED
  """The OrderItem was created but not processed for any reason, and can no longer be processed because the Event has happened"""
  EXPIRED
  """The OrderItem could not be processed due to internal service disruption inside of"""
  ERROR
  """The OrderItem has been processed and processed, but an outstanding balance remainds. This state is used specifically for our Payment Plans product. In general, exercise care in dealing with OrderItems in this state, because a default on future payments remains possible."""
  PARTIALLY_PAID
  """The OrderItem was created and, but requires authorizeation by the Buyer."""
  UNAUTHORIZED
  """The OrderItem was created and was transferred to another buyer."""
  TRANSFERRED
  """The OrderItem was created and was upgraded to a new ticket type. This OrderItem is no longer valid for entry."""
  UPGRADED
}

"""Rates are product types available for sale - most typically these are tickets, but they are also configurable as Passes, and in the future other meta product types may be added"""
type Rate {
  """Optional capacity for this rate"""
  capacity: Int
  clientGroup: RateClientGroup!
  """Optional description for this rate"""
  description: String
  """Displays a price that contains taxes and fees if the listing has all-in pricing enabled. If the listing does not have it enabled, this is identical to price."""
  displayPrice: Float!
  endStamp: Int
  exclusionRules: [JSON!]
  id: ID!
  """A limit of the number of tickets of this type sellable for each TimeSlot on an Event"""
  maxQuantity: Int
  """Maximum number of times this rate may be redeemed (scanned). Single redemption if null"""
  maxRedemptions: Int
  """Optional amount of maximum tickets allowed when purchasing this rate"""
  maxTickets: Int
  """The minimum price of this type of ticket, used only in PWYW/donation tickets"""
  minPrice: Float!
  """Minimum seconds between redemptions (scans). No minimum if null."""
  minRedemptionInterval: Int
  """Optional amount of minimum tickets required when purchasing this rate"""
  minTickets: Int
  name: String!
  optionName: String
  """Confirmed OrderItems in the Order, don't include transfers"""
  orderItems: OrderItemConnection!
  """The price of this type of ticket - 0.0 if free"""
  price: Float!
  """Optional promotion tag"""
  promotionPill: String
  """Time (in seconds) setting when purchased orders on this rate will be released to the fan"""
  releaseOffset: Int
  """Total net sales"""
  sales: Money!
  """Total net sales amount"""
  salesAmount: Float! @deprecated(reason: "Use new 'sales' field for more detail")
  """Optional number sold costItems for this rate"""
  soldCount: Int
  startStamp: Int
  state: RateState!
  """Rate type I.E Ticket, Pass, or Add-on"""
  type: RateType
}

"""The state a rate can be in"""
enum RateState {
  """The rate is available for purchase, if capacity is available"""
  ACTIVE
  """The rate is only available if the user provides a key"""
  LOCKED
  INACTIVE
  """The rate has been removed"""
  HIDDEN
}

"""A state representing which places a rate can be sold."""
enum RateClientGroup {
  """The rate can be sold both online and at-the-door"""
  EVERYWHERE
  """The rate can only be sold online"""
  ONLINE_ONLY
  """The rate can only be sold at the door"""
  AT_THE_DOOR
}

type OrderItemConnection {
  nodes(limit: Int = 10, offset: Int = 0): [OrderItem!]!
  pagination: JSON
  totalCount: Int!
}

"""An item in the order"""
type OrderItem {
  """The AddOn for this OrderItem, if the rate is an AddOnRate"""
  addOn: AddOn
  amount: Float!
  """Buyer's answers to checkout questions on the OrderItem level (i.e. Ticket)"""
  answers: [Answer]!
  """The person that owns this OrderItem, who is not always the primary buyer"""
  buyer: Buyer!
  """Whether or not the OrderItem was scanned in"""
  checkInState: CheckInState!
  """Whether this order item is in a confirmed state"""
  confirmed: Boolean
  """Cost breakdown for the Order Item"""
  costBreakdown: OrderCostItemBreakdown!
  """In UTC"""
  createdAt: Time!
  """Partially refunded amount"""
  discountPrice: Float
  """Redemption objects for any Discount applied during checkout"""
  discountRedemption: DiscountRedemption
  """Whether there are questions or answers on this order item that can be edited"""
  editable: Boolean
  """Custom attribute associated with this OrderItem, settable by the Host"""
  externalMetadata: String
  """Users first name"""
  firstName: String
  """Optional formatted price with currency code and symbol"""
  formattedPrice: String
  """Determines if the OrderItem has been fully refunded, meaning the entire monetary amount has been returned to the buyer"""
  fullyRefunded: Boolean
  id: ID!
  """Users first name"""
  lastName: String
  name: String!
  optionName: String
  """The parent transaction for this Order Item"""
  order: Order!
  """The state the Order is in"""
  orderState: OrderState!
  """Determines if the OrderItem has been partially refunded. Partially refunded meaning a partial monetary amount has been returned to the buyer"""
  partiallyRefunded: Boolean
  """The person that paid for this OrderItem, but does not necessarily own it"""
  primaryBuyer: Buyer!
  qrCode: String
  """The rate associated with this OrderItem"""
  rate: Rate!
  """The label of the seat if the Event sells seats"""
  seatLabel: String
  """The state the OrderItem is in"""
  state: OrderItemState!
  """In UTC"""
  updatedAt: Time!
  """Whether this order item can be upgraded"""
  upgradeable: Boolean
  """Whether this order item can be voided"""
  voidable: Boolean!
}

"""OrderState describes the possible states an Order may be in."""
enum OrderState {
  """The Order has been created and a charge has been authorized but not yet processed - the default state"""
  UNPAID
  """The Order has been created, but requires approval by the Host to process"""
  UNAPPROVED
  """The Order has been created, but requires pre-authorization by the cardholder"""
  NEEDS_PRE_AUTH
  """This state has been deprecated, and will be removed soon"""
  CHECKOUT
  """The Order has been created but a charge has not yet been authorized"""
  PENDING
  """The Order has been successfully processed, and payment methods have been charged"""
  PAID
  """The Order has been processed, and processing failed"""
  FAILED
  """The Order has been processed, but the payment method was declined by the upstream gateway"""
  DECLINED
  """The Order was created and processed, but has since been cancelled and any associated transactions have been reverted"""
  CANCELLED
  """The Order was created and processed, and 48 hours has passed since the Event. The funds associated with this Order are now pending a transfer to the Host"""
  ENDED
  """The Order has been processed, and funds captured by the charge have been transferred to the Event Host"""
  CLOSED
  """The Order was created but not processed for any reason, and can no longer be processed because the Event has happened"""
  EXPIRED
  """The Order could not be processed due to internal service disruption inside of"""
  ERROR
  """The Order has been processed and processed, but an outstanding balance remainds. This state is used specifically for our Payment Plans product. In general, exercise care in dealing with Orders in this state, because a default on future payments remains possible."""
  PARTIALLY_PAID
  """The Order was created and, but requires authorizeation by the Buyer."""
  UNAUTHORIZED
  """The Order was disputed. Ticket is invalid for entry, but counts towards capacity until resolved."""
  DISPUTED
}

"""An order item cost breakdown"""
type OrderCostItemBreakdown {
  """The total commission paid for this Order"""
  commission: Float
  """The total commission included paid for this Order"""
  commissionIncluded: Float
  createdAt: String
  """The currency used either for transactions or for settlement"""
  currency: CurrencyCode
  description: String
  """The total discount for this Order"""
  discount: Float
  """The total fees paid for this Order"""
  fee: Float
  """Sum of fee, commission and plan_fee per cost item"""
  feeAmount: Float
  fees: [CostItemBreakdownFee!]
  """The total fulfillment paid for this Order"""
  fulfillment: Float
  id: String
  mongoId: String
  """The total payment for this Order"""
  payment: Float
  """The plan fees paid for this Order"""
  planFee: Float
  """The price paid for this Order"""
  price: Float
  rateId: String
  """The settlement cost breakdown"""
  settlement: OrderCostBreakdown
  """The subtotal paid for this Order"""
  subtotal: Float
  taxes: [CostItemBreakdownTax!]
  """The total taxes paid for this Order"""
  taxesTotal: Float
  """Total cost item amount inclusive of fees, taxes and commissions, paid by the fan"""
  totalPaidByFan: Float
  """The transactional cost breakdown"""
  transactional: OrderCostBreakdown
  """Has this Order Item been voided"""
  voided: Boolean
  """The total commission voided for this Order"""
  voidedCommission: Float
  """The total commission included voided for this Order"""
  voidedCommissionIncluded: Float
  """The total discount voided for this Order"""
  voidedDiscount: Float
  """The total fees voided for this Order"""
  voidedFee: Float
  voidedFees: [CostItemBreakdownFee!]
  """The total payment voided for this Order"""
  voidedPayment: Float
  """The plan fees voided for this Order"""
  voidedPlanFee: Float
  """The price voided for this Order"""
  voidedPrice: Float
  """The subtotal voided for this Order"""
  voidedSubtotal: Float
  voidedTaxes: [CostItemBreakdownTax!]
  """The total taxes voided for this Order"""
  voidedTaxesTotal: Float
}

type CostItemBreakdownTax {
  amount: Float
  description: String
  percent: Float
  """The settlement cost breakdown"""
  settlement: CostItemBreakdownTax
  taxId: String
  """The transactional cost breakdown"""
  transactional: CostItemBreakdownTax
}

type CostItemBreakdownFee {
  amount: Float
  description: String
  flat: Float
  percent: Float
  """The settlement cost breakdown"""
  settlement: CostItemBreakdownFee
  src_flat: Float
  """The transactional cost breakdown"""
  transactional: CostItemBreakdownFee
}

"""An order cost breakdown by default, the transactional cost breakdown"""
type OrderCostBreakdown {
  """The total commission paid for this Order"""
  commission: Float
  """The total commission included paid for this Order"""
  commissionIncluded: Float
  """The currency used either for transactions or for settlement"""
  currency: CurrencyCode!
  """The total discount for this Order"""
  discount: Float
  """The total fees paid for this Order"""
  fee: Float
  """The fees paid for this Order"""
  fees: [CostBreakdownItem!]
  """The total fulfillment paid for this Order"""
  fulfillment: Float
  """The total payment for this Order"""
  payment: Float
  """The date the payment was made at for this Order"""
  paymentMadeAt: String!
  """The plan fees paid for this Order"""
  planFee: Float
  """The price paid for this Order"""
  price: Float
  """The settlement cost breakdown"""
  settlement: OrderCostBreakdown
  """The subtotal paid for this Order"""
  subtotal: Float
  """The taxes paid for this Order"""
  taxes: [CostBreakdownItem!]
  """The total taxes paid for this Order"""
  taxesTotal: Float
  """The transactional cost breakdown"""
  transactional: OrderCostBreakdown
  """The total commission voided for this Order"""
  voidedCommission: Float
  """The total commission included voided for this Order"""
  voidedCommissionIncluded: Float
  """The total discount voided for this Order"""
  voidedDiscount: Float
  """The total fees voided for this Order"""
  voidedFee: Float
  """The fees that were voided on this Order"""
  voidedFees: [CostBreakdownItem!]
  """The total payment voided for this Order"""
  voidedPayment: Float
  """The date the payment was voided at"""
  voidedPaymentAt: String!
  """The plan fees voided for this Order"""
  voidedPlanFee: Float
  """The price voided for this Order"""
  voidedPrice: Float
  """The subtotal voided for this Order"""
  voidedSubtotal: Float
  """The taxes that were voided on this Order"""
  voidedTaxes: [CostBreakdownItem!]
  """The total taxes voided for this Order"""
  voidedTaxesTotal: Float
}

type CostBreakdownItem {
  amount: Float
  description: String
  """The settlement cost breakdown"""
  settlement: CostBreakdownItem
  """The transactional cost breakdown"""
  transactional: CostBreakdownItem
}

"""Discount Redemptions represent unique uses of a Discount on an Order Item"""
type DiscountRedemption {
  discount: Discount!
  id: ID!
  orderItem: OrderItem!
}

"""Discounts allow Buyers to redeem a discount on their purchase"""
type Discount {
  """The literal value a Buyer needs to provide to redeem the discount"""
  code: String!
  """In UTC"""
  createdAt: Time!
  """The event to which the discount code is restricted, if applicable"""
  event: Event
  """The redemption value of the Discount - as a fixed amount"""
  fixed: Float
  id: ID!
  """The redemption value of the Discount - as a percent (represented in the range 0..1)"""
  percent: Float
  """The total number of Order Items that a Discount can be applied to"""
  quantity: Int
  """The rates to which the discount code is restricted, if applicable"""
  rates: [Rate]
  """The type of redemption value, dictates which field the redemption value should be read from (either `percent` or `fixed`)"""
  redemptionType: DiscountRedemptionType!
  """Redemption objects for this Discount"""
  redemptions: DiscountRedemptionConnection!
  """The total number of possible uses remaining"""
  remaining: Int
  state: DiscountState!
  """In UTC"""
  updatedAt: Time!
}

"""Possible states a Discount can be in"""
enum DiscountState {
  """The Discount is available for use"""
  ACTIVE
  """The Discount is not available for use"""
  INACTIVE
  """The Discount has been fully used (no quantity remaining) and cannot be redeemed"""
  USED
}

"""Possible redemption value types of Discounts"""
enum DiscountRedemptionType {
  """If percent, the value of the Discount is a percentage off"""
  PERCENT
  """If fixed, the value of the Discount is a fixed amount off"""
  FIXED
}

type DiscountRedemptionConnection {
  nodes(limit: Int = 10, offset: Int = 0): [DiscountRedemption!]!
  pagination: JSON
  totalCount: Int!
}

"""A transaction made by a Buyer for Order Items (frequently, but not exclusively, tickets for an Event)"""
type Order {
  """The access keys used for this Order"""
  accessKeys: [String]
  """Add Ons in the order"""
  addOnItems: OrderItemConnection!
  """Buyer's answers to checkout question, on the level of the Order itself"""
  answers: [Answer]!
  """whether this order is booking protected"""
  bookingProtected: Boolean
  """The Buyer who created the Order"""
  buyer: Buyer!
  """Brand of Card or Payment Method"""
  cardBrand: String
  """Whether this order is in a confirmed state"""
  confirmed: Boolean
  """Cost breakdown for the Order"""
  costBreakdown: OrderCostBreakdown!
  """In UTC"""
  createdAt: Time!
  """Whether there are questions or answers on this order that can be edited"""
  editable: Boolean
  """Each Order has one Event - the event the tickets are for"""
  event: Event!
  historical: Boolean
  """The Host of the Event the tickets on the Order are for"""
  host: Host!
  hostPurchased: Boolean!
  id: ID!
  """The invoice for an order"""
  invoice: Invoice
  """Whether an order belongs to channel partner"""
  isDcomOrder: Boolean
  """Number of accepted transfers for this order"""
  numberOfAcceptedTransfers: Int
  """Items in the order"""
  orderItems(externalMetadata: String): OrderItemConnection!
  """Where the Buyer purchased the order from"""
  origin: String
  paymentDeclineCode: PaymentDeclineCode
  """A private note created by the Host of the Event, made available to Buyers. Often contains information important to the Buyer."""
  privateNote: String
  providerSourceClient: String
  providerSourceType: ProviderSourceType
  """Collection of rate ids for the order items in this order"""
  rateIds: [ID!]
  """If the Buyer clicked a link containing a `ref` parameter, this string will return the same value. You can use this to track purchases from specific links."""
  ref: String
  """Gets a refund estimate on this order"""
  refundEstimate(orderItemRefundDatas: [OrderItemRefundData]!): Float
  state: OrderState!
  """The TimeSlot the tickets on the Order are for"""
  timeSlot: TimeSlot!
  """In UTC"""
  updatedAt: Time!
  """Whether an order item on this order can be upgraded"""
  upgradeable: Boolean
  """Whether the order was purchased using Klarna"""
  usedKlarna: Boolean
  """Whether the order was purchased using a payment plan"""
  usedPaymentPlan: Boolean
  """Valid order items count i.e. without 'upgraded' status"""
  validOrderItemsCount: Int
  """Whether an order item on this order can be voided"""
  voidable: Boolean
}

type Answer {
  id: ID!
  question: Question!
  """Value of the Answer - the actual 'answer' to the question asked to the user. Note that this field returns a string, but the content will contain stringified versions of other types like arrays. This behavior exists because GraphQL does not currently support union scalar field types. Universe recommends parsing these values as JSON in whatever consuming application you are writing."""
  value: JSON
}

type Question {
  context: AnswerContext!
  editable: String!
  hasOther: Boolean!
  id: ID!
  included: Boolean!
  index: Int!
  multiple: Boolean!
  """Question"""
  question: String!
  """Rate ids for which this question is set"""
  rateIds: [ID]!
  """Rates which this question needs to be set"""
  rates: [Rate]!
  required: Boolean!
  selectOptions: JSON
  subType: String
  """Type of the question, have no idea which values it can have"""
  type: AnswerType!
}

"""Question types"""
enum AnswerType {
  """Regular text"""
  TEXT
  """Single choice from many"""
  SELECT
  """Multiple choices from many"""
  MULTI_SELECT
  """Yes or no"""
  CHECKBOX
}

"""Answer context"""
enum AnswerContext {
  """Once per order item question"""
  ORDER_ITEM
  """Once per order question"""
  ORDER
}

"""A user who has created an Order on Universe"""
type Buyer implements User {
  admin: Boolean!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """A user-defined description"""
  description: String
  """A (potentially unconfirmed) email address - uniquely tied to the Buyer ID"""
  email: String!
  """The first name of the type implementing a User interface"""
  firstName: String
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A single field concatenating firstName and lastName"""
  name: String
  """Orders created for this Event"""
  orders: OrderConnection
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
}

type OrderConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Order!]!
  pagination: JSON
  totalCount: Int!
}

"""When a card issuer declines a payment, they will provide a reason through the use of a decline code"""
enum PaymentDeclineCode {
  """translation missing: en.misc.bank_decline_codes.approve_with_id"""
  APPROVE_WITH_ID
  """translation missing: en.misc.bank_decline_codes.call_issuer"""
  CALL_ISSUER
  """translation missing: en.misc.bank_decline_codes.card_declined"""
  CARD_DECLINED
  """translation missing: en.misc.bank_decline_codes.card_not_supported"""
  CARD_NOT_SUPPORTED
  """translation missing: en.misc.bank_decline_codes.card_velocity_exceeded"""
  CARD_VELOCITY_EXCEEDED
  """translation missing: en.misc.bank_decline_codes.currency_not_supported"""
  CURRENCY_NOT_SUPPORTED
  """translation missing: en.misc.bank_decline_codes.do_not_honor"""
  DO_NOT_HONOR
  """translation missing: en.misc.bank_decline_codes.do_not_try_again"""
  DO_NOT_TRY_AGAIN
  """translation missing: en.misc.bank_decline_codes.duplicate_transaction"""
  DUPLICATE_TRANSACTION
  """translation missing: en.misc.bank_decline_codes.expired_card"""
  EXPIRED_CARD
  """translation missing: en.misc.bank_decline_codes.fraudulent"""
  FRAUDULENT
  """translation missing: en.misc.bank_decline_codes.generic_decline"""
  GENERIC_DECLINE
  """translation missing: en.misc.bank_decline_codes.incorrect_number"""
  INCORRECT_NUMBER
  """translation missing: en.misc.bank_decline_codes.incorrect_cvc"""
  INCORRECT_CVC
  """translation missing: en.misc.bank_decline_codes.insufficient_funds"""
  INSUFFICIENT_FUNDS
  """translation missing: en.misc.bank_decline_codes.invalid_account"""
  INVALID_ACCOUNT
  """translation missing: en.misc.bank_decline_codes.invalid_amount"""
  INVALID_AMOUNT
  """translation missing: en.misc.bank_decline_codes.invalid_cvc"""
  INVALID_CVC
  """translation missing: en.misc.bank_decline_codes.invalid_expiry_year"""
  INVALID_EXPIRY_YEAR
  """translation missing: en.misc.bank_decline_codes.issuer_not_available"""
  ISSUER_NOT_AVAILABLE
  """translation missing: en.misc.bank_decline_codes.lost_card"""
  LOST_CARD
  """translation missing: en.misc.bank_decline_codes.new_account_information_available"""
  NEW_ACCOUNT_INFORMATION_AVAILABLE
  """translation missing: en.misc.bank_decline_codes.no_action_taken"""
  NO_ACTION_TAKEN
  """translation missing: en.misc.bank_decline_codes.not_permitted"""
  NOT_PERMITTED
  """translation missing: en.misc.bank_decline_codes.pickup_card"""
  PICKUP_CARD
  """translation missing: en.misc.bank_decline_codes.processing_error"""
  PROCESSING_ERROR
  """translation missing: en.misc.bank_decline_codes.restricted_card"""
  RESTRICTED_CARD
  """translation missing: en.misc.bank_decline_codes.revocation_of_all_authorizations"""
  REVOCATION_OF_ALL_AUTHORIZATIONS
  """translation missing: en.misc.bank_decline_codes.stolen_card"""
  STOLEN_CARD
  """translation missing: en.misc.bank_decline_codes.stop_payment_order"""
  STOP_PAYMENT_ORDER
  """translation missing: en.misc.bank_decline_codes.testmode_decline"""
  TESTMODE_DECLINE
  """translation missing: en.misc.bank_decline_codes.try_again_later"""
  TRY_AGAIN_LATER
  """translation missing: en.misc.bank_decline_codes.withdrawal_count_limit_exceeded"""
  WITHDRAWAL_COUNT_LIMIT_EXCEEDED
}

"""Payment methods supported by our payment systems"""
enum ProviderSourceType {
  BCH
  BTC
  DCR
  DOGE
  ETH
  LNBT
  LTC
  XMR
  XRP
  ALIPAY
  BANCONTACT
  DCOM
  EPS
  GIROPAY
  GLOBEE
  IDEAL
  INVOICE
  KLARNA
  MASTERPASS
  MULTIBANCO
  PAYPAL
  PRZELEWY
  SEPA
  SOFORT
  VISACHECKOUT
  WECHAT
  CARD
  VISA_CHECKOUT
  SEPA_DEBIT
  APPLE_PAY
  ANDROID_PAY
  GOOGLE_PAY
  OFFLINE
}

"""The invoice for an order"""
type Invoice {
  address1: String
  address2: String
  city: String
  company: String
  country: String
  fullName: String
  id: ID!
  number: Int
  state: String
  zip: String
}

"""Refund arguments related to a single OrderItem"""
input OrderItemRefundData {
  id: ID!
  amount: Float!
  refundType: RefundType!
  void: Boolean!
}

"""Specifies if a refund is flat or in percentage of the amount"""
enum RefundType {
  FLAT
  PERCENT
}

"""CheckInState describes if an OrderItem was checked in or not."""
enum CheckInState {
  """The initial check in state"""
  CHECKED_OUT
  """Check in done by the host"""
  MANUALLY_CHECKED_IN
  """QR Code was scanned at the door"""
  SCANNED_IN
  """QR Code was scanned out"""
  SCANNED_OUT
}

"""A product or service that can be sold at any of your events"""
type AddOn {
  """The currency in which the add-on is sold"""
  currency: CurrencyCode
  """A detailed description of the add-on"""
  description: String
  """Events where this add on is available. Set to [] for all events."""
  eventIds: [ID]
  events: [Event]
  """The creator of the add-on"""
  host: Host
  """Determines who pays the Universe service fee."""
  hostPaysCommission: Boolean
  id: ID
  """The name of add-on item being sold"""
  name: String
  """The rates associated with the add-on"""
  rates: [AddOnRate]
  """The taxes associated with the add-on"""
  taxes: [Tax]
}

"""Rates are product types available for sale - most typically these are tickets, in this case configured for add-on"""
type AddOnRate {
  """Associated add-on for this rate"""
  addOn: AddOn
  """Amount available after considering claims and sold items"""
  availability: Int
  """Capacities for add on rate"""
  capacities: [RateCapacity!]
  """Number of add-on items available in stock"""
  capacity: Int
  """Description of rate"""
  description: String
  """The displayed price of this specific rate with all in pricing"""
  displayPrice: Float
  eventId: String
  id: ID!
  """A URL to the event image. Custom height and width can be supplied"""
  imageUrl(
    """Height of the image"""
    height: Int = 160
    """Width of the image"""
    width: Int = 160
  ): String
  """Images of the add on option"""
  images: [Image!]
  """Maximum number of add-ons allowed per order"""
  maxQuantity: Int
  """Maximum number of times a ticket may be redeemed (scanned). Single redemption if null."""
  maxRedemptions: Int
  """Minimum number of add-ons required per order"""
  minQuantity: Int
  """Minimum seconds between redemptions (scans). No minimum if null."""
  minRedemptionInterval: Int
  """The name of the rate"""
  name: String!
  optionName: String
  """The sale price of this specific rate"""
  price: Float
  """Product number of this specific add-on rate"""
  sku: String
  """Number of add-on items available in stock"""
  soldCount: Int
  """The currency the buyer must purchase the rate in"""
  srcCurrency: String!
  """The state of a specific add-on rate"""
  state: RateState
  """The type of rate"""
  type: String!
  """Whether an add on rate has sold add-ons or not"""
  used: Boolean!
}

"""Capacity for a Rate within a Time Slot"""
type RateCapacity {
  """Available capacity count for a Rate within a Time Slot. It depends on the Event and Rate maxQuantity. Returns null if there is no maxQuantity set for Event and Rate. """
  available: Int
  countAttending: Int
  countAvailable: Int
  id: ID!
  """Rate for the capacity in a Time Slot"""
  rate: Rate!
  rateId: ID!
  timeSlotId: ID
  type: String!
}

"""A tax rate that can be applied to cost items"""
type Tax {
  """The add ons that use this tax"""
  addOns: [AddOn]
  """The creator of the tax"""
  host: Host
  id: ID
  """The name of tax"""
  name: String
  """The percentage of tax rate"""
  percent: Float
  """Tax registration number if available"""
  taxId: String
}

"""Monetary amounts (includes a currency and sales $)"""
type Money {
  """The currency of the money"""
  currency: CurrencyCode!
  """The exponent of the currency, the number of digits used after the decimal place"""
  exponent: Int!
  """Monetary amount returned as an integer in the lowest denomination (cents) to reduce floating point errors"""
  monetaryAmount: Int!
}

"""Possible Rate types."""
enum RateType {
  """The rate is for a paid ticket"""
  PAID_TICKET
  """The rate is for a free ticket"""
  FREE_TICKET
  """The rate is for a pass"""
  PASS_TICKET
  """The rate is for a pay what you can ticket"""
  PWYW_TICKET
  """The rate is for an add-on"""
  ADD_ON
}

type ThirdPartyTicketConnection {
  nodes(limit: Int = 10, offset: Int = 0): [ThirdPartyTicket!]!
  pagination: JSON
  totalCount: Int!
}

type ThirdPartyTicket {
  """In UTC"""
  createdAt: Time!
  email: String
  firstName: String
  id: ID!
  importSource: String!
  lastName: String
  rate: Rate!
  state: OrderState!
  timeSlot: TimeSlot!
  token: String!
  """In UTC"""
  updatedAt: Time!
}

"""Sales per specific day"""
type DailySales {
  """Day"""
  day: Date!
  """Sales"""
  salesAmount: Float!
}

"""The conversion tracking labels a host as set for their Event"""
type GoogleAdsSendTos {
  """the send_to field to fire on checkout modal is loaded"""
  checkout: [String!]!
  """the send_to field to fire on an event pageview"""
  pageview: [String!]!
  """the send_to field to fire on an event purchase"""
  purchase: [String!]!
  """the send_to field to list the site_tags"""
  siteTag: [String!]!
}

"""Stores the data required for WRSTBND integration"""
type WrstbndIntegration {
  """the WRSTBND user api key"""
  apiKey: String
  """In UTC"""
  createdAt: Time!
  listingId: ID!
  """is NFC enabled for this event?"""
  nfcEnabled: Boolean
  """is NFC enabled for all rates od this event?"""
  nfcEnabledAllRates: Boolean
  """is RFID enabled for this event?"""
  rfidEnabled: Boolean
  """is RFID enabled for all rates od this event?"""
  rfidEnabledAllRates: Boolean
  """In UTC"""
  updatedAt: Time!
  """the WRSTBND event id"""
  wrstbndEventId: String
}

"""Google Ads Trackers allow to store the targers and types of ads trackers"""
type GoogleAdsTracker {
  """In UTC"""
  createdAt: Time!
  id: ID!
  listingId: ID!
  """target of a tracker event"""
  sendTo: String!
  """type of a tracker event"""
  type: GoogleAdsTrackerTypes!
  """In UTC"""
  updatedAt: Time!
}

"""Valid types for google ads tracker"""
enum GoogleAdsTrackerTypes {
  """PURCHASE type for google ads tracker"""
  purchase
  """PAGEVIEW type for google ads tracker"""
  pageview
  """CHECKOUT type for google ads tracker"""
  checkout
  """SITE_TAG type for google ads tracker"""
  site_tag
}

"""Stores keys of facebook pixels ads tracker"""
type FacebookPixel {
  """In UTC"""
  createdAt: Time!
  id: ID!
  listingId: ID!
  """Pixel code"""
  pixel: String!
  """In UTC"""
  updatedAt: Time!
}

type RateConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Rate!]!
  pagination: JSON
  totalCount: Int!
}

"""True if rate with state exists and false if rate with state does not exist"""
type RateStateExists {
  inactive: Boolean!
  locked: Boolean!
  soldAtDoor: Boolean
}

type SaversConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Saver!]!
  pagination: JSON
  totalCount: Int!
}

"""Represents a Saver who Saved an Event"""
type Saver implements User {
  admin: Boolean!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """A user-defined description"""
  description: String
  """The first name of the type implementing a User interface"""
  firstName: String
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """User locale"""
  locale: Locale
  """A single field concatenating firstName and lastName"""
  name: String
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
}

type AccessKeyConnection {
  nodes(limit: Int = 10, offset: Int = 0): [AccessKey!]!
  pagination: JSON
  totalCount: Int!
}

"""Access Keys allow you to password protect tickets so you can sell tickets to a certain group of patrons. Perfect for offering special rates for members or VIPs."""
type AccessKey {
  id: ID!
  key: String!
  """The total number of locked tickets that can be purchased with a given key."""
  quantity: Int
  """The rates unlocked by this Access Key"""
  rates: [Rate!]
  state: AccessKeyState!
}

"""The state an access key can be in"""
enum AccessKeyState {
  """The Access Key is available for use"""
  ACTIVE
  """The Access Key is not available for use"""
  INACTIVE
  """The Access Key has been fully used and cannot be redeemed"""
  USED
}

type DiscountConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Discount!]!
  pagination: JSON
  totalCount: Int!
}

"""Referral Code"""
type ReferralCode {
  code: String!
  id: ID!
}

"""Customized Rate values"""
type RateCustomization {
  capacity: Int
  enabled: Boolean
  eventId: ID
  id: ID!
  listingId: ID
  price: Float
  rateId: ID
  soldCount: Int
}

"""WIP"""
type Report {
  columns: JSON!
  preview(
    """number of rows to return in the preview"""
    limit: Int = 10
    """number of rows to skip in the preview"""
    offset: Int = 0
  ): JSON!
}

"""Event category"""
type Category {
  id: ID!
  key: CategoryKey!
  """The name of the category in English"""
  name: String!
}

"""List of potential event categories"""
enum CategoryKey {
  """Other"""
  OTHER
  """Business"""
  BUSINESS
  """Music"""
  MUSIC
  """Sports"""
  SPORTS
  """Comedy"""
  COMEDY
  """Film"""
  FILM
  """Crafts"""
  CRAFTS
  """Food & Drink"""
  FOOD_DRINK
  """Fashion"""
  FASHION
  """Social"""
  SOCIAL
  """Performances"""
  PERFORMING_ARTS
  """Tech"""
  TECH
  """Galleries"""
  GALLERIES_MUSEUMS
}

"""A label on an Event indicating an interest the Event includes"""
type Tag {
  """The name of the tag"""
  name: String!
  """The slug for the tag"""
  slug: String!
  """Whether the tag is suggestable or not"""
  suggestable: Boolean
}

type ScheduleConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Schedule!]!
  pagination: JSON
  totalCount: Int!
}

"""The object that controls the creation of batch timeslots"""
type Schedule {
  """End date in YYYY/MM/DD"""
  endDate: String
  id: ID!
  """The timeslot intervals assigned to this Schedule"""
  intervals: [ScheduleInterval!]!
  """Current progress of this schedule"""
  progress: Int!
  """True if there are associated ticket sales, False if there are no associated ticket sales."""
  readOnly: Boolean
  """Start date in YYYY/MM/DD"""
  startDate: String!
  """The state this schedule is in"""
  state: ScheduleState!
  """Weekdays available in the schedule, represented by 0-6"""
  weekdaysAvailable: [Days!]!
}

"""Days"""
enum Days {
  """Sunday"""
  SUNDAY
  """Monday"""
  MONDAY
  """Tuesday"""
  TUESDAY
  """Wednesday"""
  WEDNESDAY
  """Thursday"""
  THURSDAY
  """Friday"""
  FRIDAY
  """Saturday"""
  SATURDAY
}

"""Each individual timeslot rule within a schedule"""
type ScheduleInterval {
  """The timeslot intervals assigned to this Schedule"""
  datesToSkip: [Date]!
  """How long a timeslot will last from the startHour and startMinute"""
  duration: Int!
  id: ID!
  """True when there are associated ticket sales, False when there are no assocaited ticket sales"""
  readOnly: Boolean
  """The hour when a timeslot will begin"""
  startHour: Int!
  """The minute when a timeslot will begin"""
  startMinute: Int!
}

"""The state a schedule is in"""
enum ScheduleState {
  """This schedule is currently manipulating timeslots"""
  IN_SYNC
  """This schedule is done manipulating timeslots"""
  SYNC_DONE
}

"""Report that provides overview information on order item sales"""
type TimeSlotReport {
  addOnsByDate: [JSON]
  """Number of add-ons sold"""
  addonItemsSold: Int!
  """Number of order items and add-ons sold"""
  costItemsSold: Int!
  id: ID!
  invitationsByDate: [JSON]
  """Number of invitations sent out to potential buyers"""
  invitationsSent: Int
  """The monetary value that represents the total of tickets sold in-person before Universe has made its deductions"""
  offlineAmountGross: Float
  salesByDate: [JSON]
  """Number of order items sold"""
  ticketItemsSold: Int!
  ticketsAvailableByRate: [JSON]
  ticketsByDate: [JSON]
  """Number of orders processed"""
  ticketsSold: Int!
  totalAddonItemsGross: Float
  """Monetary amount of discounts applied to order items"""
  totalAmountDiscount: Float
  """Commission amount given to Universe as payment per ticket"""
  totalCommissionIncluded: Float
  """Fees on on order items"""
  totalFee: Float
  """The monetary value that represents the total before Universe has made its deductions"""
  totalGross: Float
  """The monetary value that represents the total after Universe has made its deductions such as Service Charge"""
  totalNet: Float
  """The monetary value that represents the tickets sales collected through Distributed Commerce"""
  totalPartnerSales: Float
  """Taxes on order items"""
  totalTaxes: Float
  totalTicketItemsGross: Float
  """Taxes on Universe fees or Value Added Tax"""
  totalVatIncluded: Float
}

"""Host fields for checkout page questions"""
type HostField {
  context: String
  """In UTC"""
  createdAt: Time!
  editable: Boolean
  hasOther: Boolean
  id: ID!
  included: Boolean
  maxLength: Int
  multiple: Boolean
  name: String
  rates: [Rate!]!
  required: Boolean
  selectOptions: [String!]
  sortIndex: Int
  subtype: String
  text: String
  type: String
  """In UTC"""
  updatedAt: Time!
  value: String
}

"""Rate upgrade for a rate"""
type RateUpgrade {
  benefits: [String]
  buttonText: String
  description: String
  enabled: Boolean
  heading: String
  id: ID!
  imageUrl: String
  sourceRateIds: [ID]
  subtitle: String
  targetRateId: ID
}

"""Entry in a waitlist"""
type WaitlistSubscriber {
  did_not_buy: Boolean
  email: String
  host_marketing_opt_in: Boolean
  id: ID
  listing_id: ID
  locale: String
  tm_marketing_opt_in: Boolean
  user_id: ID
}

"""Custom Configuration for printed ticket"""
type PrintedTicketConfiguration {
  """Additional Text Line 1"""
  additionalText1: String
  """Additional Text Line 2"""
  additionalText2: String
  id: ID
  """Supporting Text"""
  supportingText: String
  """Ticket Event Name"""
  ticketEventName: String
  """Ticket Event Organizer"""
  ticketEventOrganizer: String
}

type RateCapacityConnection {
  nodes(limit: Int = 10, offset: Int = 0): [RateCapacity!]!
  pagination: JSON
  totalCount: Int!
}

"""Analytics data for Viewer"""
type Analytics {
  """Add-on revenue amount by this currency"""
  addOnSalesAmount(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): Float!
  """Add-on sales by day"""
  addOnSalesByDay(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): [DailySales!]!
  """Average OrderItem count per Order"""
  averageOrderItemCountPerOrder(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): Float
  """Average OrderItem price"""
  averageOrderItemPrice(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): Float
  """Average Order price"""
  averageOrderPrice(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): Float
  """Aggregate top buyers' locations"""
  buyersLocations(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): [BuyersLocation!]!
  """Revenue amount by this currency"""
  salesAmount(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): Float!
  """Sales by day"""
  salesByDay(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): [DailySales!]!
  """Aggregate sales information by channels"""
  salesChannels(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): [SalesChannel!]! @deprecated(reason: "this data has been moved to our new analytics platform")
  """Ticket revenue amount by this currency"""
  ticketSalesAmount(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): Float!
  """Ticket sales by day"""
  ticketSalesByDay(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): [DailySales!]!
  """Total tickets sold per currency"""
  ticketsSold(slugs: [String!], from: Date!, to: Date!, currency: CurrencyCode!): Int!
  """The most popular hour of Order purchase"""
  topHourOfPurchase(from: Date!, to: Date!, currency: CurrencyCode!, slugs: [String!]): Int
}

"""Sales data through channel"""
type SalesChannel {
  """Channel name"""
  channelName: String
  """Sales amount"""
  salesAmount: Int
  """Sales count"""
  salesCount: Int
}

"""Number of Buyers per Location"""
type BuyersLocation {
  """Number of Buyers per Location"""
  buyerCount: Int!
  """Buyers' Location"""
  location: Location!
}

type Location {
  """City name"""
  city: String!
  """Country name"""
  country: String!
}

"""Stripe connect account properties"""
type StripeConnectAccount {
  currency: StripeConnectCurrencyCode!
  """Stripe Connect Account Id"""
  id: String!
  """Payment methods associated with stripe connect account"""
  paymentMethods: [String!]
}

"""Currency codes for Stripe Connect Permissions"""
enum StripeConnectCurrencyCode {
  """USD currency"""
  USD
  """USD Terminal currency"""
  USD_TERMINAL
  """CAD currency"""
  CAD
  """EUR currency"""
  EUR
  """GBP currency"""
  GBP
  """AUD currency"""
  AUD
  """BRL currency"""
  BRL
  """CHF currency"""
  CHF
  """DKK currency"""
  DKK
  """NOK currency"""
  NOK
  """NZD currency"""
  NZD
  """SEK currency"""
  SEK
  """MXN currency"""
  MXN
  """JPY currency"""
  JPY
  """HKD currency"""
  HKD
  """SGD currency"""
  SGD
}

type CustomReportConnection {
  nodes(limit: Int = 10, offset: Int = 0): [CustomReport!]!
  pagination: JSON
  totalCount: Int!
}

"""Account level custom report"""
type CustomReport {
  _id: ID! @deprecated(reason: "Prefer camelCase to snake case. Please use the id field instead")
  additionalRecipientIds: [ID!]
  columns: [String!]!
  createdAt: String!
  created_at: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the createdAt field instead")
  """Currency parameter for filtering events in event select modal"""
  currencyFilter: String
  """The day of the week when the scheduler should send report on."""
  days: [Days]
  description: String
  """Whether the scheduler is enabled or not"""
  enabled: Boolean
  """Custom date range parameter (from) for filtering events in event select modal"""
  eventRangeFrom: String
  """Custom date range parameter (to) for filtering events in event select modal"""
  eventRangeTo: String
  events: [String!]
  externalRecipientEmails: [String!]
  filters: [JSON!]
  """The starting date of the scheduler"""
  from: Date
  """The speicific hour of the day when the report should be sent. Value must be between 0 and 23"""
  hour: Int
  id: ID!
  name: String!
  """The ordering column and direction of order prior to exporting to a CSV/XLS file. Value must be in '{COLUMN} {DIRECTION}' format"""
  order: String
  reportType: String!
  report_type: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the reportType field instead")
  """Time parameter for filtering events in event select modal"""
  timeFilter: String
  """The ending date of the scheduler"""
  to: Date
  updatedAt: String!
  updated_at: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the updatedAt field instead")
}

type AddOnConnection {
  nodes(limit: Int = 10, offset: Int = 0): [AddOn!]!
  pagination: JSON
  totalCount: Int!
}

type TaxConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Tax!]!
  pagination: JSON
  totalCount: Int!
}

type ChargebackConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Chargeback!]!
  pagination: JSON
  totalCount: Int!
}

"""Chargeback on a host"""
type Chargeback {
  amount: Float
  buyer: Buyer!
  created_at: Time
  display_currency: String
  fee: Float
  id: ID!
  order: Order!
  payment_user_id: String
  state: String
  stripe_charge_id: String
}

type WithdrawalConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Withdrawal!]!
  pagination: JSON
  totalCount: Int!
}

"""Withdrawals made by host"""
type Withdrawal {
  amount: Float
  created_at: Date
  currency: String
  email: String
  id: ID!
  state: String
}

type AccountBalanceConnection {
  nodes(limit: Int = 10, offset: Int = 0): [AccountBalance!]!
  pagination: JSON
  totalCount: Int!
}

"""Account balance of the host"""
type AccountBalance {
  currency: String
  total_balance: Float
  upcoming_funds: Float
  withdrawable_balance: Float
}

"""Set of Events"""
type EventSet implements BaseEvent {
  """Street-level address"""
  address: String!
  """All Events in the EventSet"""
  allEvents: [Event]!
  """All Additional Images"""
  allImages: [Image!]!
  """EventSet calendar fields"""
  calendar: Calendar!
  """Cover Photo"""
  coverPhoto: Image!
  """In UTC"""
  createdAt: Time!
  """A detailed description of the event"""
  description(format: ContentFormat = TEXT): String!
  """Detailed description with html"""
  descriptionHtml: String! @deprecated(reason: "Deprecated in favor of description field with argument[:format] equal to 'html'")
  """Events in the EventSet"""
  events: EventConnection!
  """Hidden Date"""
  hiddenDate: Boolean
  id: ID!
  """Other Images"""
  images: ImageConnection!
  latitude: Float!
  longitude: Float!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String!
  """A brief description"""
  title: String!
  """In UTC"""
  updatedAt: Time!
  """Event or EventSet creator"""
  user: Profile!
  """Name of the venue"""
  venueName: String
}

"""Calendar namespace for widgets"""
type Calendar {
  """List of dates with future / ongoing Events"""
  dates: [Date!]!
  """List of ongoing / future TimeSlots, sorted by startAt, unique by startDate and Event."""
  timeSlots(
    """Supply an ISO8601-formatted date string to filter time slots by date"""
    date: Date
  ): TimeSlotConnection!
}

"""Transfers represents the act of transferring one ticket from an user to another one"""
type Transfer {
  """In UTC"""
  createdAt: Time!
  email: String
  firstName: String
  id: ID!
  lastName: String
  orderItem: OrderItem
  originalOrderItem: OrderItem
  state: TransferState!
  token: String
  """In UTC"""
  updatedAt: Time!
}

"""The state a transfer can be in"""
enum TransferState {
  """The transfer has been sent to the new owner to be accepted"""
  PENDING
  """The transfer expires once event begins"""
  EXPIRED
  """The new ticket owner has accepted this transfer"""
  ACCEPTED
  """The transfer recipient declined the transfer"""
  DECLINED
  """The transfer has been cancelled"""
  CANCELLED
}

"""The user making the current GraphQL operation"""
type Viewer implements User {
  admin: Boolean!
  """The avatar URL, 160x160 pixels"""
  avatarUrl: String
  """The user has configured their account as a business"""
  business: Boolean
  """The Business Seller address for businesses in the EU"""
  businessAddress: String
  """The Business Seller Email for businesses in the EU"""
  businessEmail: String
  """The Business Seller Phone Number for businesses in the EU"""
  businessPhoneNumber: String
  """The approximate city of the location of Viewer either by saved location or IP address"""
  cityName: String
  """The user has configured email"""
  confirmed: Boolean
  """The approximate country of the location of Viewer either by saved location or IP address"""
  countryName: String
  """the currencies of the viewer's organizations"""
  currencies: [CurrencyCode!]
  """A user-defined description"""
  description: String
  """The base currency for the event"""
  displayCurrency: String
  """A (potentially unconfirmed) email address belong to the Viewer"""
  email: String
  """All Events by this Viewer"""
  events(slugs: [String!], currency: CurrencyCode, states: [EventState!]): EventConnection!
  """The first name of the type implementing a User interface"""
  firstName: String
  """The user is hosting events on Universe"""
  host: Boolean
  id: ID
  """The Business Seller Flag"""
  isBusinessSeller: Boolean
  """The last name of the type implementing a User interface"""
  lastName: String
  """The approximate latitude of the location of Viewer either by saved location or IP address"""
  latitude: Float
  """User locale"""
  locale: Locale
  """The approximate longitude of the location of Viewer either by saved location or IP address"""
  longitude: Float
  """Viewers memberships organization information"""
  memberships: MembershipConnection
  """A single field concatenating firstName and lastName"""
  name: String
  organization: Organization!
  privacyPolicyUrl: String
  """The type of the viewer account (Admin, User, Spammer, etc)"""
  role: UserRole!
  """A unique identifier, shorter version of the ID. Should be used for URI construction."""
  slug: String
  """The avatar URL, 50x50 pixels"""
  smallAvatarUrl: String
  superAdmin: Boolean!
  """The predicted TimeSlot duration from startAt to endAt in seconds"""
  timeSlotDuration: Int
  """The predicted TimeSlot startAt time"""
  timeSlotStartAt: TimeWithoutTz!
  """The transacted currency for the event"""
  transactedCurrency: String
  """Venue tagging is enabled"""
  venueTagging: Boolean
  """Fan opt in is enabled for waitlist"""
  waitlistFanOptIn: Boolean
}

type MembershipConnection {
  nodes(limit: Int = 10, offset: Int = 0): [Membership!]!
  pagination: JSON
  totalCount: Int!
}

"""Memberships are the groups that the user is a part of through different accessibility / permission levels"""
type Membership {
  """Check if the membership applies to all listings"""
  allEvents: Boolean!
  """Listings that the membership applies to"""
  eventIds: String
  id: ID!
  """The owner of the group in which the user has membership"""
  owner: Host!
  """Check the membership against a specific permission type"""
  permission(for: Permission!): Boolean!
  """Check the membership against some or all of a list of permission types"""
  permissions(
    for: [Permission!]!
    """Check whether any of the permission types apply to the membership"""
    any: Boolean = false
  ): Boolean!
}

"""Possible permission types on a team membership (dashboard/organization)"""
enum Permission {
  """Edit event details such as description, dates, checkout questions, etc., and advanced settings such as ticket transfers and waitlist options"""
  EDIT
  """Ability to delete events"""
  DELETABLE
  """Ability to publish events"""
  TRANSITION
  """Ability to customize the "Get Tickets" button"""
  DESIGN
  """Ability to manage events"""
  MANAGE
  """Promote the event using social deals, discount codes, social integrations, etc."""
  PROMOTE
  """Access to At-the-Door (via the BoxOffice app) to scan and sell tickets onsite"""
  CHECK_IN
  """Access sales and ticket data on the event and account dashboards, and through integrations"""
  MANAGE_OVERVIEW
  """Access to account level Reports"""
  REPORT
  """Ability to view orders, contact buyers, refund and cancel orders"""
  ORDERS
  """Ability view and contact attendees, and resend tickets"""
  ATTENDEES
  """Ability to add or upload attendees"""
  ADD_ATTENDEES
  """Ability to export Guestlists Report (ideal for checking people in at the door)"""
  GUESTS_REPORT
  """Ability to export Attendee's Report (includes data collected during checkout)"""
  ATTENDEES_REPORT
  """Access to Order Reports (includes a cost breakdown of each order)"""
  ORDERS_REPORT
  """Ability to export Check-in Report (list of all the check-ins and check-outs)"""
  CHECK_INS_REPORT
  """Ability to export Cancellations and Refunds Report"""
  CANCELLATIONS_REPORT
  """Access to Tickets Report (cost breakdown for each ticket)"""
  TICKETS_REPORT
  """Ability to export Requires Approval Report (identifies all orders that have not been approved yet)"""
  APPROVALS_REPORT
  """Ability to export Event Summary Settlement Report"""
  EVENT_SUMMARY_SETTLEMENT_REPORT
  """Ability to export TM Audit Reports"""
  TM_AUDIT_REPORT
  """Ability to export Audit Reports (shows a high-level daily summary of ticket sales)"""
  AUDIT_REPORT
  """Receive all emails regarding account activity"""
  RECEIVES_EMAILS
  """Full access to all events and ability to create events"""
  CREATABLE
  """Access to Universe Service Invoices"""
  SERVICE_INVOICE
  """Ability to manage all Add-ons"""
  MANAGE_ADD_ONS
  """Ability to export Payout Settlement Report"""
  PAYOUT_SETTLEMENT_REPORT
  """Access to Add-ons Reports (includes the cost breakdown for each add-on)"""
  ADD_ONS_REPORT
  """Access to Account Activity Reports (financial summary of all money that came into and out of your account)"""
  ACTIVITY_REPORT
  """Access to Event Reports (A summary of tickets sold by ticket type on the event level)"""
  EVENTS_REPORT
  """Access to Timeslot Reports (summary of tickets sold by ticket type on the timeslot level)"""
  TIMESLOTS_REPORT
  """Access to Chargeback Reports (all chargebacks for orders processed on Universe Payments)"""
  CHARGEBACKS_REPORT
  """Access to Rebate Reports (all rebates received)"""
  REBATES_REPORT
  """Access to Rebate Invoice Reports (all rebates received)"""
  REBATE_INVOICE
  """Access to Invoice Reports"""
  INVOICE_REPORT
  """Access to Timeslot Changes Reports"""
  TIMESLOT_CHANGES_REPORT
  """Access to printed ticket configuration"""
  PRINTED_TICKET_CONFIGURATION
}

"""Stores the data required for WRSTBND passtype"""
type WrstbndPasstype {
  """In UTC"""
  createdAt: Time!
  id: ID!
  """is NFC enabled for this passtype?"""
  nfcEnabled: Boolean
  """is NFC placeholder enabled for this passtype?"""
  nfcEnabledPlaceholder: Boolean
  rateId: ID!
  """is RFID enabled for this passtype?"""
  rfidEnabled: Boolean
  """is rfid placeholder enabled for this passtype?"""
  rfidEnabledPlaceholder: Boolean
  """In UTC"""
  updatedAt: Time!
  wrstbndIntegrationId: ID!
  """the WRSTBND passtype id"""
  wrstbndPasstypeId: String
}

"""The pricing plan that a host is on."""
enum PricingPlan {
  """The starter pricing plan."""
  STARTER
  """The standard pricing plan."""
  STANDARD
  """A custom pricing plan."""
  PRO
}

type Country {
  code: CountryCode!
  continent: Continent!
  currency: CurrencyCode!
  geonameId: String!
  id: ID!
  name: String!
  universeAvailable: Boolean!
}

"""Two letter continent code"""
enum Continent {
  """Africa"""
  AF
  """Antarctica"""
  AN
  """Asia"""
  AS
  """Europe"""
  EU
  """North America"""
  NA
  """Oceania"""
  OC
  """South America"""
  SA
}

"""Calendar namespace for the new single widgets"""
type CalendarWidget {
  """Whether to enable waitlist for the Event"""
  allowWaitlist: Boolean!
  """Available months for the event grouped by year"""
  availableMonths: [AvailableMonths]!
  """Available Timeslots"""
  calendarDates: [CalendarWidgetDate]!
  """Calendar timeslots"""
  calendarTimeslots: [CalendarWidgetTimeslot]!
  """A detailed description of the event"""
  description(format: ContentFormat = TEXT): String!
  """Determines if a given event has only locked rates"""
  hasAllLockedRates: Boolean!
  hostId: ID!
  id: ID!
  """Whether to enable All in pricing for US Event"""
  lnAllInPricing: Boolean
  """Determines whether or not to show quantity filter"""
  showQuantityFilter: Boolean!
  """Determines whether or not to show ticket type filter"""
  showTicketTypeFilter: Boolean!
  """Determines whether or not to show time of day filter"""
  showTimeOfDayFilter: Boolean!
  """Tickets are sold out for this Event"""
  soldOut: Boolean!
  """Sold out dates"""
  soldOutDates: [String]!
  """Determines if a given event is timed entry based"""
  timedEntry: Boolean!
  """Timezone of the event location"""
  timezone: String!
  """A brief description"""
  title: String!
  """Currency that is displayed and charged in"""
  transactionCurrency: CurrencyCode!
}

"""Available months for an event grouped by year."""
type AvailableMonths {
  """Event month"""
  months: [Int]!
  """Event year"""
  year: Int!
}

"""CalendarWidgetTimeslot"""
type CalendarWidgetTimeslot {
  """Remaining capacity left for a timeslot"""
  countAvailable: Int
  """Timeslot capacity by rate"""
  countAvailableByRate: String
  """Timeslot end date and time in UTC"""
  endAt: String!
  """Determines if the end date has passed or not"""
  endDatePassed: Boolean!
  """Extended timeslot end date and time in UTC"""
  extendedEndAt: String!
  id: ID!
  """max price"""
  maxPrice: Float
  """min price"""
  minPrice: Float
  """Tickets are sold out for this timeslot"""
  soldOut: Boolean!
  """Timeslot start date and time in UTC"""
  startAt: String!
  """Timeslot total count by rate"""
  totalCountByRate: String
  """Urgency indicator message"""
  urgencyMessageLeft: String
  """Verbose urgency indicator message """
  urgencyMessageTimeslot: String
}

"""CalendarWidgetDate"""
type CalendarWidgetDate {
  """calendar timeslots"""
  calendarTimeslotIds: [ID]!
  """date"""
  date: String
  """show urgency indicator"""
  showUrgencyIndicator: Boolean
  """totalCount"""
  totalCount: Int
}

"""This type provides data necessary for Upgrade Tickets modal to function on manage panel"""
type UpgradableOrder {
  """Buyer's answers to checkout questions on the Order level"""
  answers: [Answer]!
  id: ID!
  """Collection of rate ids for the upgradable order items in this order"""
  rateIds: [ID!]
  """Whether the order has upgradable items"""
  upgradable: Boolean!
  """Order items that can be upgraded to a different rate"""
  upgradableOrderItems: [UpgradableOrderItem!]!
}

"""An order item in the order that is upgradable to another rate"""
type UpgradableOrderItem {
  """Buyer's answers to checkout questions on the OrderItem level (i.e. CostItem)"""
  answers: [Answer]!
  """In UTC"""
  createdAt: Time!
  id: ID!
  name: String!
  """Owner of upgradable order item"""
  owner: OrderItemOwner!
  rateId: ID!
  """In UTC"""
  updatedAt: Time!
  """Determines wether OrderItem is upgradable"""
  upgradable: Boolean!
  """Rates to which an oder item can be upgraded to"""
  upgradableToRates: [Rate]!
}

"""Information about a user that owns an order item(s)"""
type OrderItemOwner {
  email: String!
  name: String!
}

"""Serves the Event Information Tickets tab on the Manage Panel"""
type ManageTickets {
  """Is the event country allowed for Paypal?"""
  allowedPaypalAtCountry: Boolean!
  """The currency the host receives funds in"""
  baseCurrency: String!
  """Capacity number for the event"""
  capacity: Int
  country: Country
  hostId: ID!
  id: ID!
  """Is the event paypal?"""
  paypal: Boolean!
  """Is Paypal enabled on the organization"""
  paypalEnabledAtOrganization: Boolean!
  rates: [ManageTicketsRate!]!
  refundOffset: RefundOffset!
  refundOffsetType: RefundOffsetType!
  """The currency the buyer must purchase in"""
  srcCurrency: String!
  """The timeSlots assigned to this Event"""
  timeSlots: [ManageWhenTimeslot!]!
  """Determines whether or not an event admits visitors to an event between a set time"""
  timedEntry: Boolean!
  """Timezone of the event location"""
  timezone: String!
  """Flag to show a warning to the fan when capacity is close to reaching capacity"""
  urgencyIndicatorEnabled: Boolean!
  """When to show an alert that the Event is almost sold out"""
  urgencyIndicatorThreshold: Float
  """Determines whether or not an event is virtual"""
  virtual: Boolean!
  wrstbndIntegration: WrstbndIntegration
}

type ManageTicketsRate {
  """The default access key for a given locked rate"""
  accessKey: String
  """Optional number for the ticket capacity on this rate - default is unlimited"""
  capacity: Int
  clientGroup: RateClientGroup
  """If rate is associated with DCOM"""
  dcomEnabled: Boolean!
  """Description for the rate"""
  description: String
  displayPrice: Float
  """UNIX Timestamp"""
  endStamp: Int
  """List of rules that exclude a rate from displaying against given timeslot(s)"""
  exclusionRules: [JSON!]
  id: ID!
  """Maximum number of times this ticket type may be redeemed (scanned). Single redemption if null."""
  maxRedemptions: Int
  """Optional number for the maximum amount of tickets to be sold on this rate"""
  maxTickets: Int
  """The minimum price of this type of ticket, used only in PWYW/donation tickets"""
  minPrice: Float!
  """Minimum seconds between redemptions (scans). No minimum if null."""
  minRedemptionInterval: Int
  """Optional number for the minimum amount of tickets to be sold on this rate"""
  minTickets: Int
  """Name for the rate"""
  name: String!
  """The price of this type of ticket - 0.0 if free"""
  price: Float!
  """Optional promotion tag"""
  promotionPill: String
  """Seconds before event to release the tickets"""
  releaseOffset: Int
  """Sort index of the rate"""
  sortIndex: Int
  """The currency the buyer must purchase the rate in"""
  srcCurrency: String!
  """UNIX Timestamp"""
  startStamp: Int
  state: RateState!
  type: RateType!
  """If rate has sold order items"""
  used: Boolean!
  """WRSTBND passtypes for the rate"""
  wrstbndPasstype: WrstbndPasstype
}

type ManageWhenTimeslot {
  """Timeslot end date and time in the timezone of the event"""
  endAt: TimeWithoutTz!
  id: ID!
  """Whether the timeslot can be modified or not"""
  readOnly: Boolean!
  """Timeslot start date and time in the timezone of the event"""
  startAt: TimeWithoutTz!
}

"""Serves the Event Information When (Timed Entry) tab on the Manage Panel"""
type ManageWhenTimedEntry {
  id: ID!
  """The schedules assigned to this Event"""
  schedules: [Schedule!]!
  """The timeSlots assigned to this Event"""
  timeSlots: [ManageWhenTimeslot!]!
  """Timezone of the event location"""
  timezone: String!
  """Determines whether or not an event is virtual"""
  virtual: Boolean!
}

"""Serves the Event Information When (Regular Entry) tab on the Manage Panel"""
type ManageWhenRegularEntry {
  address: String!
  country: Country
  customVenueName: Boolean
  hiddenDate: Boolean!
  hiddenFromTicketmaster: Boolean
  id: ID!
  latitude: Float!
  longitude: Float!
  """Is the event paypal?"""
  paypal: Boolean!
  """Is Paypal enabled on the organization"""
  paypalEnabledAtOrganization: Boolean!
  privacy: String!
  publishLaterAt: Time
  ticketmasterVenueId: String
  """The timeSlots assigned to this Event"""
  timeSlots: [ManageWhenTimeslot!]!
  """Timezone of the event location"""
  tz: String!
  venueName: String
  venueTagging: Boolean
  """Determines whether or not an event is virtual"""
  virtual: Boolean!
  """Virtual connection info"""
  virtualInfo: String
}

"""Serves the Event Information Customize tab on the Manage Panel"""
type ManageCustomize {
  """Optional additional images for the event (promotional photos, venue photos)"""
  additionalImages: [Image!]!
  """Optional field that the host sets for additional contact information"""
  contactDetails: String
  """Cover photo for the event (min 100x100px, max 2MB). Auto-generated if no initial entry."""
  coverPhoto: Image!
  """Event photo for the event (min 1110x444px, max 5MB). Auto-generated if no initial entry."""
  eventPhoto: Image!
  id: ID!
  """Content that will be provided to buyer's only"""
  privateNote: String
}

"""Serves the Customize Tickets tab on the Event Manage Panel"""
type ManageCustomizeTickets {
  """Listing is all in pricing or not"""
  allInPricing: Boolean!
  """Date objects for the ticket customization calendar"""
  calendarDates: [CustomizeTicketsDate!]!
  """Capacity of the listing"""
  capacity: Int
  """First available month"""
  firstMonthWithEvents: String!
  """ID of the listing"""
  id: ID!
  """Last available month"""
  lastMonthWithEvents: String!
  """Customized values for Ticket Type - Timeslot pairs"""
  rateCustomizations: [RateCustomization!]!
  """Total number of rate customizations for this listing"""
  rateCustomizationsCount: Int!
  """Ticket types in original state for all timeslots"""
  rates: [Rate!]!
  """All timeslots for the listing"""
  timeslots: [CustomizeTicketsTimeslot!]!
  """Timezone of the event location"""
  timezone: String!
  """Total number of unique price changes"""
  uniquePriceChangesCount: Int!
}

"""Date objects for the Customize Tickets calendar"""
type CustomizeTicketsDate {
  """Calendar timeslots for the tickets customization page"""
  calendarTimeslotIds: [ID]!
  """date"""
  date: String
}

"""Timeslot objects for the Customize Tickets tab"""
type CustomizeTicketsTimeslot {
  """Capacity of the timeslot"""
  capacity: Int
  """Timeslot end date and time"""
  endAt: String!
  id: ID!
  isCustomized: Boolean
  isPast: Boolean
  rateIds: [ID]!
  """Ticket sold count"""
  soldCount: Int
  """Timeslot start date and time"""
  startAt: String!
}

"""Serves the channel partner information on Distribute Commerce tab on the Manage Panel"""
type ManageChannelPartnerSales {
  """Id of channel partner"""
  channelPartnerId: String!
  """Name of channel partner"""
  channelPartnerName: String!
  """Distributed Commerce is enabled for the listing"""
  dcomAllowed: Boolean!
  id: ID!
  """Total remaining tickets for the listing by channel partner"""
  remainingTickets: Int!
  """Status of the offers for channel partner"""
  status: String!
  """Total tickets sold for listing by channel partner"""
  ticketsSold: Int!
  """Total sales for listing by channel partner"""
  totalSales: Float!
}

"""Serves the partner offers information on Distribute Commerce tab on the Manage Panel"""
type PartnerOffers {
  """ID of channel partner"""
  channelPartnerId: String!
  """Name of channel partner"""
  channelPartnerName: String!
  """ID of partner offer"""
  id: ID!
  """Mask name of partner offer"""
  maskName: String!
  """Price of partner offer"""
  offerPrice: Float!
  """Service Fee of partner offer"""
  serviceFee: Float!
  """Ticket type of partner offer"""
  ticketType: String!
  """Venue fee (facility fee) of partner offer"""
  venueFee: Float!
}

"""Serves the Event Information Basics tab on the Manage Panel"""
type ManageBasics {
  address: String!
  attractions: [Attraction]
  categoryId: String!
  country: Country
  customVenueName: Boolean
  description: String!
  hiddenFromTicketmaster: Boolean
  id: ID!
  latitude: Float!
  longitude: Float!
  """Is the event paypal?"""
  paypal: Boolean!
  """Is Paypal enabled on the organization"""
  paypalEnabledAtOrganization: Boolean!
  privacy: String!
  publishLaterAt: Time
  ticketmasterVenueId: String
  """The timeSlots assigned to this Event"""
  timeSlots: [ManageWhenTimeslot!]!
  timedEntry: Boolean!
  title: String!
  """Timezone of the event location"""
  tz: String!
  venueName: String
  venueTagging: Boolean
}

type Attraction {
  bio: String
  data: JSON
  discoveryId: String!
  id: ID!
  legacyId: String
  name: String
  ticketmasterImageUrl: String
}

"""Returns fields required for TimeSlotSelect modal to function"""
type TimeSlotSelect {
  """Dates on which there are time slots"""
  datesWithTimeSlots: [String!]
}

"""Namespace for the timeslot filter query"""
type TimeslotFilter {
  id: ID!
  """Timeslot filter timeslots"""
  timeslots: [TimeslotFilterTimeslot]!
}

"""TimeslotFilterTimeslot"""
type TimeslotFilterTimeslot {
  countAttending: Int
  countAvailable: Int
  """Timeslot end date and time in events timezone"""
  endAt: String!
  """In Event's time zone"""
  endDate: Date!
  """UNIX Timestamp"""
  endStamp: Int!
  id: ID!
  """Timeslot start date and time in events timezone"""
  startAt: String!
  """In Event's time zone"""
  startDate: Date!
  """UNIX Timestamp"""
  startStamp: Int!
  """An IANA Time Zone string"""
  tz: String!
}

type TicketmasterVenuesConnection {
  nodes(limit: Int = 10, offset: Int = 0): [TicketmasterVenue!]!
  pagination: JSON
  totalCount: Int!
}

type TicketmasterVenue {
  address: Address_TicketmasterVenue
  city: String
  country: String
  countryCode: String
  dma: String
  id: ID!
  location: Location_TicketmasterVenue
  market: String
  name: String
  postalCode: String
  state: State_TicketmasterVenue
  url: String
}

type State_TicketmasterVenue {
  name: String
  stateCode: String
}

type Address_TicketmasterVenue {
  line1: String
  line2: String
  line3: String
}

type Location_TicketmasterVenue {
  latitude: Float
  longitude: Float
}

type TicketmasterAttractionConnection {
  nodes(limit: Int = 10, offset: Int = 0): [TicketmasterAttraction!]!
  pagination: JSON
  totalCount: Int!
}

type TicketmasterAttraction {
  discoveryId: String!
  legacyId: String
  name: String!
}

type StripeTerminalReaderCollection {
  hasMore: Boolean!
  nodes: [StripeTerminalReader]
}

"""Stripe terminal reader that we get from stripe"""
type StripeTerminalReader {
  action: StripeTerminalReaderAction
  deleted: Boolean
  device_sw_version: String
  device_type: String
  id: ID
  ip_address: String
  label: String
  last_seen_at: Int
  livemode: Boolean
  location: String
  metadata: JSON
  object: String
  serial_number: String
  status: String
}

"""The most recent action performed by the reader"""
type StripeTerminalReaderAction {
  failure_code: String
  failure_message: String
  process_payment_intent: JSON
  process_setup_intent: JSON
  refund_payment: JSON
  set_reader_display: JSON
  status: String
  type: String
}

"""Properties for Stripe pagination"""
input StripePaginationAttributesInputType {
  endingBefore: String
  startingAfter: String
  limit: Int
}

"""Stripe terminal location that we get from stripe"""
type StripeTerminalLocation {
  address: StripeTerminalLocationAddress
  deleted: Boolean
  display_name: String
  id: ID!
  livemode: Boolean
  metadata: JSON
  object: String
}

"""Stripe terminal location address that we get from stripe"""
type StripeTerminalLocationAddress {
  city: String
  country: String
  line1: String
  line2: String
  postal_code: String
  state: String
}

"""Autogenerated return type of DiscountCreate"""
type DiscountCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  discount: Discount
  errors: [String!]
}

"""Autogenerated input type of DiscountCreate"""
input DiscountCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  code: String!
  state: DiscountState!
  redemptionType: DiscountRedemptionType!
  quantity: Int
  percent: Float
  fixed: Float
  userId: ID!
}

"""Autogenerated return type of DiscountDelete"""
type DiscountDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  discount: Discount
  errors: [String!]
}

"""Autogenerated input type of DiscountDelete"""
input DiscountDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  user_id: ID
}

"""Autogenerated return type of DiscountsUpdate"""
type DiscountsUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  discounts: [Discount]!
  errors: [[Error!]]!
}

"""Error message with the corresponding key it belongs to"""
type Error {
  key: String!
  message: String!
}

"""Autogenerated input type of DiscountsUpdate"""
input DiscountsUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  discounts: [Discount_UpdateDiscount!]!
}

input Discount_UpdateDiscount {
  id: ID!
  code: String
  state: DiscountState
  redemptionType: DiscountRedemptionType
  quantity: Int
  percent: Float
  fixed: Float
}

"""Autogenerated return type of DiscountsCreate"""
type DiscountsCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  discounts: [Discount!]
  errors: [String!]
}

"""Autogenerated input type of DiscountsCreate"""
input DiscountsCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  codes: [String!]!
  state: DiscountState!
  redemptionType: DiscountRedemptionType!
  quantity: Int
  percent: Float
  fixed: Float
  userId: ID!
}

"""Autogenerated return type of HostGaIntegrationUpdate"""
type HostGaIntegrationUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  host: Host
}

"""Autogenerated input type of HostGaIntegrationUpdate"""
input HostGaIntegrationUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  hostGaIntegration: Host_GaIntegration!
}

input Host_GaIntegration {
  hostId: ID!
  googleAnalyticsId: String!
  googleAnalyticsEcommerce: Boolean!
}

"""Autogenerated return type of LocaleChange"""
type LocaleChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]!
  viewer: Viewer
}

"""Autogenerated input type of LocaleChange"""
input LocaleChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  locale: Locale!
}

"""Autogenerated return type of SeatsSyncRates"""
type SeatsSyncRatesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of SeatsSyncRates"""
input SeatsSyncRatesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of SeatsPublishDraft"""
type SeatsPublishDraftPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of SeatsPublishDraft"""
input SeatsPublishDraftInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of RateCreate"""
type RateCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  rate: Rate
}

"""Autogenerated input type of RateCreate"""
input RateCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  eventId: ID!
  rate: RateCreateInputType!
}

"""Properties for RateCreate mutation"""
input RateCreateInputType {
  attributes: RateCreateAttributes!
}

"""Attributes that define a template for a ticket offering"""
input RateCreateAttributes {
  """Name of the ticket"""
  name: String
  """Description of the ticket"""
  description: String
  """Price of the ticket"""
  price: Float
  """Min price of the ticket (For PWYW_TICKET only)"""
  minPrice: Float
  """Number of tickets available"""
  capacity: Int
  """Where this ticket is available"""
  clientGroup: RateClientGroup
  """Used to specify tickets as being locked, hidden, active, etc"""
  state: RateState
  """When the ticket is available for sale"""
  saleStart: Time
  """When the ticket is no longer available for sale"""
  saleEnd: Time
  """Minimum number of tickets required per order"""
  minQuantity: Int
  """Maximum number of tickets allowed per order"""
  maxQuantity: Int
  """Maximum number of times a ticket may be redeemed (scanned)"""
  maxRedemptions: Int
  """Minimum seconds between redemptions (scans)"""
  minRedemptionInterval: Int
  """When to release purchased tickets to attendees"""
  releaseOffset: ReleaseOffset
  """Ticket type"""
  type: RateCreateType
  """Access key for locked rates"""
  accessKey: AccessKeyInputType
  """Rate exclusion rules"""
  exclusionRules: [JSON!]
  """Optional promotion tag"""
  promotionPill: String
}

"""How long before the event would you like to release the ticket?"""
enum ReleaseOffset {
  """Tickets will be released to attendees immediately"""
  IMMEDIATELY
  """Tickets will be released to attendees 1 day before the event"""
  ONE_DAY
  """Tickets will be released to attendees 2 days before the event"""
  TWO_DAYS
  """Tickets will be released to attendees 3 days before the event"""
  THREE_DAYS
  """Tickets will be released to attendees 4 days before the event"""
  FOUR_DAYS
  """Tickets will be released to attendees 5 days before the event"""
  FIVE_DAYS
  """Tickets will be released to attendees 6 days before the event"""
  SIX_DAYS
  """Tickets will be released to attendees 7 days before the event"""
  ONE_WEEK
  """Tickets will be released to attendees 14 days before the event"""
  TWO_WEEKS
  """Tickets will be released to attendees 21 days before the event"""
  THREE_WEEKS
  """Tickets will be released to attendees 28 days before the event"""
  FOUR_WEEKS
  """Tickets will never be released to attendees"""
  NEVER
}

"""Possible types to set on the createRate mutation."""
enum RateCreateType {
  """The rate is for a paid ticket"""
  PAID_TICKET
  """The rate is for a free ticket"""
  FREE_TICKET
  """The rate is for a pay what you can ticket"""
  PWYW_TICKET
}

"""Properties for AccessKey creation"""
input AccessKeyInputType {
  """Access key"""
  key: String!
}

"""Autogenerated return type of RateUpdate"""
type RateUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  rate: Rate
}

"""Autogenerated input type of RateUpdate"""
input RateUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  rate: RateUpdateInputType!
}

"""Properties for RateUpdate mutation"""
input RateUpdateInputType {
  id: ID
  attributes: RateUpdateAttributes!
}

"""Shared updatable Rate attributes"""
input RateUpdateAttributes {
  """Name of the ticket"""
  name: String
  """Description of the ticket"""
  description: String
  """Price of the ticket"""
  price: Float
  """Min price of the ticket (For PWYW_TICKET only)"""
  minPrice: Float
  """Number of tickets available"""
  capacity: Int
  """Where this ticket is available"""
  clientGroup: RateClientGroup
  """When the ticket is available for sale"""
  saleStart: Time
  """When the ticket is no longer available for sale"""
  saleEnd: Time
  """Minimum number of tickets required per order"""
  minQuantity: Int
  """Maximum number of tickets allowed per order"""
  maxQuantity: Int
  """Maximum number of times this ticket type may be redeemed (scanned). Single redemption if null."""
  maxRedemptions: Int
  """Minimum seconds between redemptions (scans)"""
  minRedemptionInterval: Int
  """When to release purchased tickets to attendees"""
  releaseOffset: ReleaseOffset
  """Ticket type"""
  type: RateCreateType
  """Access key for locked rates"""
  accessKey: AccessKeyInputType
  """Used to specify tickets as being locked, hidden, active, etc"""
  state: RateState
  sku: String
  """Rate exclusion rules"""
  exclusionRules: [JSON!]
  """Optional promotion tag"""
  promotionPill: String
  """DCOM is enabled for the ticket"""
  dcomEnabled: Boolean
  """Sort index of the rate"""
  sortIndex: Int
  """Wrstbnd Passtype integration with rate"""
  wrstbndPasstype: WrstbndPasstypeInputType
}

"""Input type for WRSTBND Passtype data"""
input WrstbndPasstypeInputType {
  id: ID
  rateId: ID
  wrstbndIntegrationId: ID
  rfidEnabled: Boolean!
  nfcEnabled: Boolean!
}

"""Autogenerated return type of RatesUpdate"""
type RatesUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  rates: [Rate!]
}

"""Autogenerated input type of RatesUpdate"""
input RatesUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  rates: [RateUpdateInputType]!
}

"""Autogenerated return type of RateUpgradeCreate"""
type RateUpgradeCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  rate_upgrade: RateUpgrade
}

"""Autogenerated input type of RateUpgradeCreate"""
input RateUpgradeCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  targetRateId: ID!
  sourceRateIds: [ID!]
  enabled: Boolean
  heading: String!
  subtitle: String!
  description: String!
  benefits: [String!]
  buttonText: String!
  imageUrl: String!
}

"""Autogenerated return type of RateUpgradeUpdate"""
type RateUpgradeUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  rate_upgrade: RateUpgrade
}

"""Autogenerated input type of RateUpgradeUpdate"""
input RateUpgradeUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  rateUpgradeUpdate: RateUpgradeUpdates!
}

input RateUpgradeUpdates {
  id: ID!
  attributes: RateUpgradeUpdateAttributes
}

input RateUpgradeUpdateAttributes {
  targetRateId: ID
  sourceRateIds: [ID]
  enabled: Boolean
  heading: String
  subtitle: String
  description: String
  benefits: [String]
  buttonText: String
  imageUrl: String
}

"""Autogenerated return type of RateUpgradeDelete"""
type RateUpgradeDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  rate_upgrade: RateUpgrade
}

"""Autogenerated input type of RateUpgradeDelete"""
input RateUpgradeDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of EventSave"""
type EventSavePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  event: Event
}

"""Autogenerated input type of EventSave"""
input EventSaveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  eventId: ID!
}

"""Autogenerated return type of EventUpdate"""
type EventUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventUpdate"""
input EventUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  attributes: Event_EventUpdate!
}

input Event_EventUpdate {
  title: String
  descriptionHtml: String
  address: String
  latitude: Float
  longitude: Float
  country: String
  tz: String
  transactionCurrency: String
  settlementCurrency: String
  contactDetails: String
  allInPricing: Boolean
  privacy: String
  venueName: String
  customVenueName: Boolean
  ticketmasterVenueId: String
  socialButtons: Boolean
  hiddenDate: Boolean
  hiddenFromTicketmaster: Boolean
  hideAttractionsFromTicketmaster: Boolean
  updateTMVenueInfo: Boolean
  maxQuantity: Int
  urgencyIndicatorEnabled: Boolean
  urgencyIndicatorThreshold: Float
  privateNote: String
  virtual: Boolean
  showQuantityFilter: Boolean
  showTicketTypeFilter: Boolean
  showTimeOfDayFilter: Boolean
  virtualInfo: String
  refundPolicy: RefundPolicyInputType
  publishLaterAt: Time
  coverPhoto: ImageInputType
  eventPhoto: ImageInputType
  additionalPhotos: [ImageUpdateInputType!]
  getTicketsText: String
  category: Category_EventUpdate
  rates: [RateUpdateInputType!]
  timeSlots: [TimeSlot_EventUpdate!]
  schedules: [Schedule_EventUpdate!]
  googleAnalytics4Id: String
  googleAnalyticsEcommerce: Boolean
  googleAnalyticsId: String
  mailchimpApiKey: String
  mailchimpListId: String
  facebookPixels: [FacebookPixelInputType!]
  googleAdsTrackers: [GoogleAdsTrackerInputType!]
  wrstbndIntegration: WrstbndIntegrationInputType
  hostFields: [HostFieldInputType!]
  attractions: [AttractionType!]
}

"""Properties for a Refund policy on event creation"""
input RefundPolicyInputType {
  attributes: RefundPolicyAttributes!
}

"""Attributes that define a template for a refund policy"""
input RefundPolicyAttributes {
  """Time offset"""
  offset: RefundOffset
  """Time scope"""
  type: RefundOffsetType
}

"""Image for listings, avatars, and add on options"""
input ImageInputType {
  uploadId: String!
  isGif: Boolean
  cropWidth: Int
  cropHeight: Int
  cropX: Int
  cropY: Int
}

"""Image for listings, avatars, and add on options"""
input ImageUpdateInputType {
  id: ID
  uploadId: String
  isGif: Boolean
  cropWidth: Int
  cropHeight: Int
  cropX: Int
  cropY: Int
}

input Category_EventUpdate {
  id: ID!
}

input TimeSlot_EventUpdate {
  id: ID
  startAt: TimeWithoutTz
  endAt: TimeWithoutTz
}

"""Used to bulk update recurring timeslots based on certain rules and intervals"""
input Schedule_EventUpdate {
  id: ID
  startDate: Date
  endDate: Date
  """Days of the week timeslots will be available"""
  weekdaysAvailable: [Days!]
  intervals: [Schedule_Intervals_EventUpdate!]
}

"""Each recurring timeslots start time and duration"""
input Schedule_Intervals_EventUpdate {
  id: ID
  startHour: Int
  startMinute: Int
  """The length of the interval in seconds"""
  duration: Int
  datesToSkip: [Date!]
}

"""Input type for a facebook pixel."""
input FacebookPixelInputType {
  id: ID
  listingId: ID
  pixel: String
  """destroys this entry"""
  destroy: Boolean
}

"""Input type for an google ads trackers."""
input GoogleAdsTrackerInputType {
  id: ID
  listingId: ID
  type: GoogleAdsTrackerTypes!
  sendTo: String
  """destroys this entry"""
  destroy: Boolean
}

"""Input type for WRSTBND integration data"""
input WrstbndIntegrationInputType {
  id: ID
  listingId: ID
  wrstbndEventId: String
  apiKey: String
  rfidEnabled: Boolean
  nfcEnabled: Boolean
  nfcEnabledAllRates: Boolean
  rfidEnabledAllRates: Boolean
}

"""Input type for a host field."""
input HostFieldInputType {
  id: ID
  listingId: ID
  name: String
  type: String
  subtype: String
  context: String
  included: Boolean
  required: Boolean
  editable: Boolean
  multiple: Boolean
  value: String
  sortIndex: Int
  hasOther: Boolean
  text: String
  rateIds: [ID!]
  selectOptions: [String!]
}

"""Input type for Attraction"""
input AttractionType {
  discoveryId: ID!
  delete: Boolean
}

"""Autogenerated return type of EventCreate"""
type EventCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventCreate"""
input EventCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  event: Event_EventCreate!
  publish: Boolean
}

input Event_EventCreate {
  category: Category_EventCreate!
  rates: [RateCreateInputType!]!
  timeSlots: [TimeSlot_EventCreate!]
  schedules: [Schedule_EventCreate!]
  title: String!
  descriptionHtml: String!
  address: String!
  longitude: Float!
  latitude: Float!
  transactionCurrency: String
  settlementCurrency: String
  contactDetails: String
  allInPricing: Boolean
  coverPhoto: ImageInputType
  eventPhoto: ImageInputType
  additionalPhotos: [ImageInputType!]
  privacy: String
  userId: ID
  venueName: String
  ticketmasterVenueId: String
  hiddenFromTicketmaster: Boolean
  hideAttractionsFromTicketmaster: Boolean
  customVenueName: Boolean
  socialButtons: Boolean
  hiddenDate: Boolean
  maxQuantity: Int
  urgencyIndicatorEnabled: Boolean
  urgencyIndicatorThreshold: Float
  privateNote: String
  refundPolicy: RefundPolicyInputType
  publishLaterAt: Time
  sendPurchaseNotifications: Boolean
  virtual: Boolean
  virtualInfo: String
  availableCountries: [CountryCode]
  isBusinessSeller: Boolean
  businessEmail: String
  businessPhoneNumber: String
  businessAddress: String
  attractions: [AttractionType!]
}

input Category_EventCreate {
  id: ID!
}

input TimeSlot_EventCreate {
  startAt: TimeWithoutTz!
  endAt: TimeWithoutTz!
}

"""Used to bulk create recurring timeslots based on certain rules and intervals"""
input Schedule_EventCreate {
  startDate: Date!
  endDate: Date
  """Days of the week timeslots will be available"""
  weekdaysAvailable: [Days!]
  intervals: [Schedule_Intervals_EventCreate!]!
}

"""Each recurring timeslots start time and duration"""
input Schedule_Intervals_EventCreate {
  startHour: Int!
  startMinute: Int!
  """The length of the interval in seconds"""
  duration: Int!
  datesToSkip: [Date!]
}

"""Autogenerated return type of EventDuplicate"""
type EventDuplicatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventDuplicate"""
input EventDuplicateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  startAt: TimeWithoutTz!
  endAt: TimeWithoutTz!
  title: String
  accessKeys: Boolean
  discountCodes: Boolean
  attractions: Boolean
}

"""Autogenerated return type of EventPublish"""
type EventPublishPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventPublish"""
input EventPublishInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of EventUnpublish"""
type EventUnpublishPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventUnpublish"""
input EventUnpublishInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of EventDelete"""
type EventDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of EventDelete"""
input EventDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of EventReport"""
type EventReportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  event: Event
}

"""Autogenerated input type of EventReport"""
input EventReportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of AttendeesMessage"""
type AttendeesMessagePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  event: Event
}

"""Autogenerated input type of AttendeesMessage"""
input AttendeesMessageInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  messageType: MessageType!
  message: String!
  timeSlotIds: [ID!]
  rateIds: [ID!]
  datetime: Time
}

"""Types of filters by which to send messages"""
enum MessageType {
  AFTER_DATE
  BY_RATE
  CHECKED_IN
  UNAPPROVED
  DECLINED
  ALL
}

"""Autogenerated return type of HostFieldDelete"""
type HostFieldDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  hostField: HostField
}

"""Autogenerated input type of HostFieldDelete"""
input HostFieldDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  listingId: ID!
}

"""Autogenerated return type of TimeSlotUpdate"""
type TimeSlotUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  timeSlot: TimeSlot
}

"""Autogenerated input type of TimeSlotUpdate"""
input TimeSlotUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  startTime: Time
  endTime: Time
  sendEmail: Boolean!
}

"""Autogenerated return type of TimeslotRateCustomization"""
type TimeslotRateCustomizationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  rateCustomizationsCount: Int
  rates: [Rate]
  success: Boolean
  uniquePriceChangesCount: Int
}

"""Autogenerated input type of TimeslotRateCustomization"""
input TimeslotRateCustomizationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  eventId: ID!
  timeslotId: ID!
  capacity: Int
  rateCustomizations: [RateCustomization_TimeslotRateCustomization!]!
}

input RateCustomization_TimeslotRateCustomization {
  """Event to be customized"""
  timeslotId: ID!
  """Ticket type to be customized"""
  rateId: ID!
  """Customized capacity for ticket type timeslot pair"""
  capacity: Int
  """Ticket type is enabled for timeslot when true and disabled when false"""
  enabled: Boolean
  """Price to be customized"""
  price: Float
}

"""Autogenerated return type of EventSetReport"""
type EventSetReportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  eventSet: EventSet
}

"""Autogenerated input type of EventSetReport"""
input EventSetReportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of CustomReportCreate"""
type CustomReportCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  custom_report: CustomReport
  errors: [String!]
}

"""Autogenerated input type of CustomReportCreate"""
input CustomReportCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
  description: String
  reportType: String!
  columns: [String!]!
  filters: [JSON!]
  events: [String!]
  from: Date
  to: Date
  days: [Days!]
  hour: Int
  enabled: Boolean!
  order: String
  timeFilter: String
  eventRangeFrom: Date
  eventRangeTo: Date
  currencyFilter: String
  additionalRecipientIds: [ID!]
  externalRecipientEmails: [String!]
}

"""Autogenerated return type of CustomReportDelete"""
type CustomReportDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  custom_report: CustomReport
  errors: [String!]
}

"""Autogenerated input type of CustomReportDelete"""
input CustomReportDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of CustomReportUpdate"""
type CustomReportUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  custom_report: CustomReport
  errors: [String!]
}

"""Autogenerated input type of CustomReportUpdate"""
input CustomReportUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  name: String
  description: String
  reportType: String
  columns: [String!]
  filters: [JSON!]
  events: [String!]
  from: Date
  to: Date
  days: [Days!]
  hour: Int
  enabled: Boolean!
  order: String
  timeFilter: String
  eventRangeFrom: Date
  eventRangeTo: Date
  currencyFilter: String
  additionalRecipientIds: [ID!]
  externalRecipientEmails: [String!]
}

"""Autogenerated return type of TransferDecline"""
type TransferDeclinePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  transfer: Transfer
}

"""Autogenerated input type of TransferDecline"""
input TransferDeclineInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
}

"""Autogenerated return type of TransferAccept"""
type TransferAcceptPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  transfer: Transfer
}

"""Autogenerated input type of TransferAccept"""
input TransferAcceptInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
  answers: [JSON!]
}

"""Autogenerated return type of AddOnCreate"""
type AddOnCreatePayload {
  addOn: AddOn
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
}

"""Autogenerated input type of AddOnCreate"""
input AddOnCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  addOn: AddOnInputType!
}

input AddOnInputType {
  id: ID
  hostId: ID
  taxIds: [ID]
  eventIds: [ID]
  attributes: AddOnAttributes
}

input AddOnAttributes {
  name: String
  description: String
  currency: CurrencyCode
  hostPaysCommission: Boolean
  rates: [AddOnRateInputType]
  images: [ImageInputType]
}

"""Properties for AddOnRate mutation"""
input AddOnRateInputType {
  id: ID
  attributes: AddOnRateAttributes
}

"""Shared updatable AddOnRate attributes"""
input AddOnRateAttributes {
  name: String
  description: String
  state: RateState
  price: Float
  sku: String
  optionName: String
  capacity: Int
  minQuantity: Int
  maxQuantity: Int
  maxRedemptions: Int
  minRedemptionInterval: Int
}

"""Autogenerated return type of AddOnDelete"""
type AddOnDeletePayload {
  addOn: AddOn
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
}

"""Autogenerated input type of AddOnDelete"""
input AddOnDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  hostId: ID
}

"""Autogenerated return type of AddOnUpdate"""
type AddOnUpdatePayload {
  addOn: AddOn
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
}

"""Autogenerated input type of AddOnUpdate"""
input AddOnUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  addOn: AddOnInputType!
}

"""Autogenerated return type of TaxCreate"""
type TaxCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  tax: Tax
}

"""Autogenerated input type of TaxCreate"""
input TaxCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  tax: TaxInputType!
}

"""Properties for Tax mutation"""
input TaxInputType {
  id: ID
  attributes: TaxAttributesType
}

"""Attributes for Tax mutation"""
input TaxAttributesType {
  name: String
  percent: Float
  taxId: String
  userId: ID
}

"""Autogenerated return type of OrderItemCheckIn"""
type OrderItemCheckInPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  orderItem: OrderItem
}

"""Autogenerated input type of OrderItemCheckIn"""
input OrderItemCheckInInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of OrderItemCheckOut"""
type OrderItemCheckOutPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  orderItem: OrderItem
}

"""Autogenerated input type of OrderItemCheckOut"""
input OrderItemCheckOutInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of ExternalMetadataUpdate"""
type ExternalMetadataUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  orderItem: OrderItem
}

"""Autogenerated input type of ExternalMetadataUpdate"""
input ExternalMetadataUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  externalMetadata: String!
}

"""Autogenerated return type of OrderItemResend"""
type OrderItemResendPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  orderItem: OrderItem!
}

"""Autogenerated input type of OrderItemResend"""
input OrderItemResendInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of OrderItemAttendeeInfoChange"""
type OrderItemAttendeeInfoChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String]
  orderItem: OrderItem
}

"""Autogenerated input type of OrderItemAttendeeInfoChange"""
input OrderItemAttendeeInfoChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  firstName: String
  lastName: String
  email: String
  answers: [AnswerInputType!]!
  newAnswers: [NewAnswerInputType!]!
}

"""Input type for an answer."""
input AnswerInputType {
  id: ID!
  value: Any
}

"""Any type. Should only be used for checkout questions"""
scalar Any

"""Input type for a new answer."""
input NewAnswerInputType {
  questionId: ID!
  value: Any
}

"""Autogenerated return type of OrderResend"""
type OrderResendPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order!
}

"""Autogenerated input type of OrderResend"""
input OrderResendInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  receiptOnly: Boolean = false
}

"""Autogenerated return type of OrderBuyerInfoChange"""
type OrderBuyerInfoChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderBuyerInfoChange"""
input OrderBuyerInfoChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  firstName: String
  lastName: String
  email: String
  answers: [AnswerInputType!]!
  newAnswers: [NewAnswerInputType!]!
}

"""Autogenerated return type of MarkInvoiceAsPaid"""
type MarkInvoiceAsPaidPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order!
}

"""Autogenerated input type of MarkInvoiceAsPaid"""
input MarkInvoiceAsPaidInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of OrderRefund"""
type OrderRefundPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderRefund"""
input OrderRefundInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  orderItemRefundDatas: [OrderItemRefundData!]!
  totalReturning: Int!
  transactionRefund: Boolean!
  cancelNoRefund: Boolean!
}

"""Autogenerated return type of OrderTimeSlotUpdate"""
type OrderTimeSlotUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderTimeSlotUpdate"""
input OrderTimeSlotUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  timeSlotId: ID!
}

"""Autogenerated return type of BulkOrderTimeSlotUpdate"""
type BulkOrderTimeSlotUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [Error!]
  orders: [Order!]
}

"""Autogenerated input type of BulkOrderTimeSlotUpdate"""
input BulkOrderTimeSlotUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  orderIds: [ID!]!
  timeSlotId: ID!
}

"""Autogenerated return type of OrderUpgrade"""
type OrderUpgradePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderUpgrade"""
input OrderUpgradeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  answers: [QuestionInputType!]!
  upgrades: [UpgradeInputType!]!
}

"""Input type for an question."""
input QuestionInputType {
  name: String!
  value: Any
}

"""Properties for OrderUpgrade mutation"""
input UpgradeInputType {
  orderItemId: ID!
  newRateId: ID!
  answers: [QuestionInputType!]!
}

"""Autogenerated return type of OrderApprove"""
type OrderApprovePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderApprove"""
input OrderApproveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of OrderDecline"""
type OrderDeclinePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  order: Order
}

"""Autogenerated input type of OrderDecline"""
input OrderDeclineInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of ResendEmailConfirmation"""
type ResendEmailConfirmationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
}

"""Autogenerated input type of ResendEmailConfirmation"""
input ResendEmailConfirmationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ChannelPartnerOffersStatusToggle"""
type ChannelPartnerOffersStatusTogglePayload {
  channelPartnerId: String
  channelPartnerName: String
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: String
  status: Boolean
  success: Boolean
}

"""Autogenerated input type of ChannelPartnerOffersStatusToggle"""
input ChannelPartnerOffersStatusToggleInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channelPartnerId: String!
  listingId: String!
}

"""Autogenerated return type of ImportThirdPartyTicket"""
type ImportThirdPartyTicketPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  importedCount: Int
}

"""Autogenerated input type of ImportThirdPartyTicket"""
input ImportThirdPartyTicketInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  importSource: String!
  listingId: ID!
  data: [ThirdPartyTicketInputType!]!
}

"""Input type for Third Party Tickets"""
input ThirdPartyTicketInputType {
  eventId: ID!
  rateId: ID!
  token: String!
  firstName: String
  lastName: String
  email: String
}

"""Autogenerated return type of ThirdPartyTicketDeleteByProvider"""
type ThirdPartyTicketDeleteByProviderPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  numDeleted: Int!
}

"""Autogenerated input type of ThirdPartyTicketDeleteByProvider"""
input ThirdPartyTicketDeleteByProviderInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  listingId: String!
  importSources: [String!]!
}

"""Autogenerated return type of WaitlistSubscriberCreate"""
type WaitlistSubscriberCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  waitlist_subscriber: WaitlistSubscriber
}

"""Autogenerated input type of WaitlistSubscriberCreate"""
input WaitlistSubscriberCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
  ticketmasterOptIn: Boolean!
  hostOptIn: Boolean!
  listingId: ID!
  userId: ID
  locale: String
}

"""Autogenerated return type of StripeTerminalReaderCreate"""
type StripeTerminalReaderCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  terminalReaderId: String
}

"""Autogenerated input type of StripeTerminalReaderCreate"""
input StripeTerminalReaderCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  listingId: ID!
  registrationCode: String!
  displayName: String!
  locationId: String!
  currency: String
}

"""Autogenerated return type of StripeTerminalReaderUpdate"""
type StripeTerminalReaderUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  stripeTerminalReader: StripeTerminalReader
}

"""Autogenerated input type of StripeTerminalReaderUpdate"""
input StripeTerminalReaderUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  stripeTerminalReaderId: String!
  label: String
  currency: CurrencyCode
  listingId: ID
}

"""Autogenerated return type of StripeTerminalReaderDelete"""
type StripeTerminalReaderDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  deleted: Boolean
  errors: [String!]
  id: String
  object: String
}

"""Autogenerated input type of StripeTerminalReaderDelete"""
input StripeTerminalReaderDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  stripeTerminalReaderId: String
  currency: CurrencyCode
  listingId: ID
}

"""Autogenerated return type of StripeTerminalLocationCreate"""
type StripeTerminalLocationCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  terminalLocationId: String
}

"""Autogenerated input type of StripeTerminalLocationCreate"""
input StripeTerminalLocationCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  listingId: ID
  currency: CurrencyCode
  attributes: StripeTerminalLocationInputType!
}

"""Properties for Stripe Terminal Location creation"""
input StripeTerminalLocationInputType {
  displayName: String!
  address: StripeTerminalLocationAddressInputType!
}

"""Properties for Stripe Terminal Location creation"""
input StripeTerminalLocationAddressInputType {
  city: String
  country: String!
  line1: String!
  line2: String
  state: String
  postalCode: String!
}

"""Autogenerated return type of StripeTerminalReaderCancel"""
type StripeTerminalReaderCancelPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  success: Boolean
}

"""Autogenerated input type of StripeTerminalReaderCancel"""
input StripeTerminalReaderCancelInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  ticketId: ID!
}

"""Autogenerated return type of PrintedTicketConfigurationManage"""
type PrintedTicketConfigurationManagePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  printedTicketConfiguration: PrintedTicketConfiguration
}

"""Autogenerated input type of PrintedTicketConfigurationManage"""
input PrintedTicketConfigurationManageInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  listingId: ID!
  attributes: PrintedTicketConfigurationInputType!
}

"""Properties for Printed Ticket Configuration"""
input PrintedTicketConfigurationInputType {
  supportingText: String
  ticketEventOrganizer: String
  ticketEventName: String!
  additionalText1: String
  additionalText2: String
}

"""Autogenerated return type of PrintingLogCreate"""
type PrintingLogCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  errors: [String!]
  printingLog: PrintingLog
}

"""PrintingLog object"""
type PrintingLog {
  id: ID
  orderId: String
  page: PrintingLogPage
  source: PrintingLogSource
  userId: String
}

"""The page printing button was clicked"""
enum PrintingLogPage {
  """Order & attendees page"""
  ORDERS_AND_ATTENDEES
  """Add an order page"""
  ADD_AN_ORDER
}

"""The source printing button was clicked"""
enum PrintingLogSource {
  """universe.com"""
  WEB
}

"""Autogenerated input type of PrintingLogCreate"""
input PrintingLogCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  orderId: ID!
  page: PrintingLogPage!
  source: PrintingLogSource!
}

"""Paginate the datas you fetch"""
input Pagination {
  """Indicate the page number (from 1)"""
  page: Int!
  """Indicate the number of items in one page"""
  itemsPerPage: Int
}

"""Change how the data is sorted"""
input Sort {
  """Indicate which field it will sort using"""
  field: String!
  """Indicate how it is sorted ("ASC" or "DESC) (default: "ASC")"""
  order: String
}

"""a Card filters"""
input CardsFilters {
  """Filter on the card's category (Pokemon, Trainer or Energy)"""
  category: String
  """Filter on the card's decription"""
  description: String
  """Filter for the card energy type (normal or special)"""
  energyType: String
  """Filter for the previous evolution of the current pokémon"""
  evolveFrom: String
  """Filter on the Pokémon's HPs"""
  hp: Int
  """Filter on the card id"""
  id: ID
  """Filter for the card's local id"""
  localId: String
  """Filter on the pokémon national pokédex number"""
  dexId: Int
  """Filter on the illustrator name"""
  illustrator: String
  """Filter on ths Pokémon's level"""
  level: Int
  """Filter on the Card's name"""
  name: String
  """
  Filter on the card's rarity
  
  see: https://api.tcgdex.net/v2/en/rarities for the full list
  """
  rarity: String
  """Filter on the card's regulation mark"""
  regulationMark: String
  """Filter on the Card evolution stage"""
  stage: String
  """Filter on the card suffix"""
  suffix: String
  """Filter on the trainer type"""
  trainerType: String
  """Filter on the retreat point cost"""
  retreat: Int
}

"""Define what is a card for GraphQL"""
type Card {
  """The pokémon abilities"""
  abilities: [AbilitiesListItem]
  """The pokémon attacks"""
  attacks: [AttacksListItem]
  """The card category ('Pokemon' | 'Trainer' | 'Energy')"""
  category: String!
  """The card description (mostly the Poédex description)"""
  description: String
  """The pokémon(s) Pokédex IDs (Pokémons appearing on the card image & name)"""
  dexId: [Int]
  """the energy/trainer effect"""
  effect: String
  """the energy type ('Normal' | 'Special')"""
  energyType: String
  """the previous evolution of the current pokémon"""
  evolveFrom: String
  """the Pokémon's HPs"""
  hp: Int
  """the card id"""
  id: String!
  """the illustrator name"""
  illustrator: String
  """The card's image if available (see the docs for more details)"""
  image: String
  """The Pokémon's item"""
  item: Item
  """The card legality in tournaments"""
  legal: Legal!
  """The Pokémon level"""
  level: Int
  """the card's local id"""
  localId: String!
  """the Card's name"""
  name: String!
  """
  the card's rarity
  
  see: https://api.tcgdex.net/v2/en/rarities for the full list
  """
  rarity: String!
  """the card's regulation mark"""
  regulationMark: String
  """The pokémon resistances"""
  resistances: [WeakResListItem]
  """The Card retreat cost"""
  retreat: Int
  """The card's set"""
  set: Set!
  """the Card evolution stage"""
  stage: String
  """the card suffix"""
  suffix: String
  """the trainer type"""
  trainerType: String
  """The pokémon type(s) (trivia: Even the TCG implemented at some point multiple types for a single card)"""
  types: [String]
  """The card variants"""
  variants: Variants
  """The pokémon weaknesses"""
  weaknesses: [WeakResListItem]
}

"""define a single ability"""
type AbilitiesListItem {
  """The ability effect"""
  effect: String
  """The ability name"""
  name: String
  """the ability type ('Pokemon Power' | 'Poke-BODY' | 'Poke-POWER' | 'Ability' | 'Ancient Trait')"""
  type: String
}

"""define a single attack"""
type AttacksListItem {
  """The attack cost in energies (can be affected by the effect)"""
  cost: [String]
  """The attack damage (can be affected by the effect)"""
  damage: String
  """The attack additionnal effect"""
  effect: String
  """The attack name"""
  name: String!
}

"""Indicate the item a pokémon has on him"""
type Item {
  """the item effect"""
  effect: String!
  """the item name"""
  name: String!
}

"""Indicate the legality of a card for official tournaments"""
type Legal {
  """Is the card playable in expanded tournaments?"""
  expanded: Boolean
  """Is the card playable in standard tournaments?"""
  standard: Boolean
}

"""Definition for the Weakness and REsistance elements"""
type WeakResListItem {
  """the Weakness/resistance type"""
  type: String!
  """the Weakness/resistance modifier (can be 2x or 30+ or nothing)"""
  value: String
}

"""All the card variants"""
type Variants {
  """is the card available in a first edition version?"""
  firstEdition: Boolean!
  """can the card be found has an holo?"""
  holo: Boolean!
  """can the card be found without special elements?"""
  normal: Boolean!
  """Can the card be found a a reverse holo version?"""
  reverse: Boolean!
  """was the card a wPromo card?"""
  wPromo: Boolean!
}

"""Describe a single set"""
type Set {
  """Indicate how much cards is in the set"""
  cardCount: CardCount!
  """list the cards in the set"""
  cards: [Card]!
  """The Set id"""
  id: String!
  """The set logo if available"""
  logo: String
  """The set's name"""
  name: String!
  """The set's symbol if available"""
  symbol: String
  """The Set serie"""
  serie: Serie!
  """The set official release date"""
  releaseDate: String!
  """The set tcgOnline code if available in the APP"""
  tcgOnline: String
}

"""Filters for the set query"""
input SetFilters {
  """The Set id"""
  id: String
  """The set's name"""
  name: String
  """The Set serie"""
  serie: String
  """The set official release date"""
  releaseDate: String
  """The set tcgOnline code if available in the APP"""
  tcgOnline: String
}

"""
Indicate how much cards a set contains

It also indicate how much card for a specific variant
"""
type CardCount {
  """The number of first edition cards in the set"""
  firstEd: Int
  """The number of holo cards in the set"""
  holo: Int
  """The number of normal cards in the set"""
  normal: Int
  """The number of cards that are not hidden (generally in the bottom left/right)"""
  official: Int!
  """The number of reverse cards in the set"""
  reverse: Int
  """The total number of cards in the set"""
  total: Int!
}

"""A Pokémon TCG serie"""
type Serie {
  """The Serie ID"""
  id: String!
  """The serie's logo if available"""
  logo: String
  """the serie's name"""
  name: String!
  """the list of sets that are part of the serie"""
  sets: [Set]!
}

"""The Serie filters"""
input SerieFilters {
  """the serie's id"""
  id: String
  """The name of the serie"""
  name: String
}

"""currently unused but is the general endpoint for every other elements"""
type StringEndpoint {
  """The list of cards that are available in the endpoint"""
  cards: [Card]!
  """The endpoint element name"""
  name: String!
}
